<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Plex Exporter Admin</title>
  <style>
    :root {
      --color-bg: #13161b;
      --color-surface: #1b1f26;
      --color-panel: #212631;
      --color-border: #2c323f;
      --color-text: #f5f6f9;
      --color-muted: #9aa6b8;
      --color-accent: #e5a00d;
      --color-accent-strong: #f5bb39;
      --color-success: #46d369;
      --color-danger: #ef5b5b;
      --color-info: #38bdf8;
      --radius: 12px;
      --radius-sm: 8px;
      --transition: 0.18s ease-in-out;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at top left, rgba(229, 160, 13, 0.08), var(--color-bg));
      color: var(--color-text);
      min-height: 100vh;
      display: flex;
    }

    a {
      color: var(--color-accent);
    }

    .app-shell {
      display: flex;
      width: 100%;
      min-height: 100vh;
    }

    .toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 50;
      pointer-events: none;
    }

    .toast {
      background: rgba(15, 17, 21, 0.92);
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 12px 16px;
      min-width: 220px;
      max-width: 320px;
      color: var(--color-text);
      box-shadow: 0 18px 32px rgba(0, 0, 0, 0.28);
      opacity: 0;
      transform: translateY(-8px);
      transition: opacity 0.2s ease, transform 0.2s ease;
      pointer-events: auto;
    }

    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }

    .toast-success { border-left: 3px solid var(--color-success); }
    .toast-error { border-left: 3px solid var(--color-danger); }
    .toast-info { border-left: 3px solid var(--color-accent); }

    .sidebar {
      width: 240px;
      background: linear-gradient(180deg, rgba(16, 17, 20, 0.95), rgba(16, 17, 20, 0.88));
      border-right: 1px solid rgba(255, 255, 255, 0.04);
      padding: 28px 22px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .brand {
      margin: 0;
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .brand-sub {
      margin: 0;
      color: var(--color-muted);
      font-size: 13px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .nav-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .nav-button {
      border: none;
      background: transparent;
      color: var(--color-muted);
      font-weight: 600;
      letter-spacing: 0.01em;
      padding: 10px 14px;
      border-radius: var(--radius-sm);
      text-align: left;
      cursor: pointer;
      transition: background var(--transition), color var(--transition), transform var(--transition);
    }

    .nav-button:hover {
      color: var(--color-text);
      transform: translateX(4px);
    }

    .nav-button.active {
      background: rgba(229, 160, 13, 0.16);
      color: var(--color-text);
      box-shadow: 0 8px 24px rgba(229, 160, 13, 0.18);
    }

    .sidebar-footer {
      margin-top: auto;
      display: flex;
      flex-direction: column;
      gap: 10px;
      font-size: 13px;
      color: var(--color-muted);
    }

    .auto-toggle {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
    }

    .auto-toggle input {
      width: 42px;
      height: 24px;
      border-radius: 12px;
      appearance: none;
      background: rgba(255, 255, 255, 0.12);
      position: relative;
      transition: background 0.2s ease;
    }

    .auto-toggle input::after {
      content: "";
      position: absolute;
      top: 3px;
      left: 4px;
      width: 18px;
      height: 18px;
      border-radius: 9px;
      background: #0d0f13;
      transition: transform 0.2s ease;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.45);
    }

    .auto-toggle input:checked {
      background: linear-gradient(135deg, var(--color-accent), var(--color-accent-strong));
    }

    .auto-toggle input:checked::after {
      transform: translateX(18px);
    }

    .main {
      flex: 1;
      padding: 32px 40px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 16px;
    }

    .page-header h2 {
      margin: 0;
      font-size: 26px;
      letter-spacing: -0.01em;
    }

    .page-header p {
      margin: 6px 0 0;
      color: var(--color-muted);
      font-size: 14px;
      max-width: 520px;
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    button {
      font-family: inherit;
      font-size: 14px;
      font-weight: 600;
      border: none;
      border-radius: var(--radius-sm);
      padding: 10px 16px;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn {
      background: rgba(255, 255, 255, 0.06);
      color: var(--color-text);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .btn:hover:not(:disabled) {
      transform: translateY(-1px);
      border-color: rgba(229, 160, 13, 0.5);
      box-shadow: 0 10px 18px rgba(229, 160, 13, 0.14);
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--color-accent), var(--color-accent-strong));
      color: #0d0f13;
      border: none;
    }

    .btn-danger {
      background: linear-gradient(135deg, #ff6b6b, var(--color-danger));
      color: #0d0f13;
    }

    .btn-compact {
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 600;
    }

    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
      gap: 16px;
    }

    .metric-card {
      background: linear-gradient(135deg, rgba(229, 160, 13, 0.1), rgba(27, 31, 38, 0.95));
      border-radius: var(--radius);
      border: 1px solid rgba(229, 160, 13, 0.2);
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      box-shadow: 0 16px 32px rgba(229, 160, 13, 0.12);
    }

    .metric-card h3 {
      margin: 0;
      font-size: 14px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.75);
    }

    .metric-value {
      font-size: 34px;
      font-weight: 700;
    }

    .metric-sub {
      margin-top: auto;
      font-size: 13px;
      color: rgba(255, 255, 255, 0.7);
    }

    .panel-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 16px;
    }

    .panel {
      background: var(--color-panel);
      border-radius: var(--radius);
      border: 1px solid rgba(255, 255, 255, 0.05);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      box-shadow: 0 16px 30px rgba(0, 0, 0, 0.22);
    }

    .panel header {
      display: flex;
      justify-content: space-between;
      gap: 16px;
      align-items: flex-start;
    }

    .panel header h3 {
      margin: 0;
      font-size: 18px;
    }

    .panel header span {
      color: var(--color-muted);
      font-size: 13px;
    }

    .info-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
      font-size: 14px;
    }

    .info-item {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      padding-bottom: 8px;
    }

    .info-item:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }

    .history-row {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 10px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .history-row:last-child {
      border-bottom: none;
    }

    .history-meta {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
    }

    .history-details {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .history-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .history-status {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .history-status.sent {
      color: var(--color-success);
    }

    .history-status.failed {
      color: var(--color-danger);
    }

    .label {
      color: var(--color-muted);
      font-weight: 500;
    }

    .value {
      color: var(--color-text);
      font-weight: 600;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .chip-success {
      background: rgba(70, 211, 105, 0.15);
      color: var(--color-success);
    }

    .chip-danger {
      background: rgba(239, 91, 91, 0.15);
      color: var(--color-danger);
    }

    .chip-info {
      background: rgba(56, 189, 248, 0.18);
      color: var(--color-info);
    }

    .view {
      display: none;
      flex-direction: column;
      gap: 24px;
    }

    .view.active {
      display: flex;
    }

    .card {
      background: var(--color-panel);
      border-radius: var(--radius);
      border: 1px solid rgba(255, 255, 255, 0.05);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 18px;
      box-shadow: 0 16px 28px rgba(0, 0, 0, 0.2);
    }

    .card h3 {
      margin: 0;
      font-size: 18px;
    }

    .card p {
      margin: 0;
      color: var(--color-muted);
      font-size: 14px;
    }

    .option-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }

    .checkbox {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: rgba(255, 255, 255, 0.04);
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.07);
      font-size: 13px;
    }

    .checkbox input {
      width: 16px;
      height: 16px;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .input-stack {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 16px;
    }

    .input-stack input {
      padding: 10px 12px;
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.03);
      color: var(--color-text);
      font-size: 14px;
    }

    .input-stack input::placeholder {
      color: var(--color-muted);
    }

    .log-view {
      background: #101217;
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.06);
      padding: 14px;
      font-family: "JetBrains Mono", "Fira Code", Consolas, monospace;
      font-size: 13px;
      line-height: 1.5;
      max-height: 280px;
      overflow: auto;
      white-space: pre-wrap;
    }

    .log-entry {
      margin: 0;
      padding: 5px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.04);
    }

    .log-entry:last-child {
      border-bottom: none;
    }

    .log-meta {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      margin-right: 12px;
      color: var(--color-muted);
    }

    .muted {
      color: var(--color-muted);
      font-size: 13px;
    }

    label.input-label {
      font-size: 13px;
      font-weight: 600;
      color: var(--color-muted);
    }

    input[type="text"],
    input[type="email"],
    input[type="number"],
    select {
      width: 100%;
      background: #151820;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: var(--radius-sm);
      padding: 10px 12px;
      color: var(--color-text);
      font-family: inherit;
      font-size: 14px;
    }

    input:focus,
    select:focus {
      outline: none;
      border-color: rgba(229, 160, 13, 0.6);
      box-shadow: 0 0 0 3px rgba(229, 160, 13, 0.18);
    }

    details {
      background: rgba(255, 255, 255, 0.04);
      border-radius: var(--radius-sm);
      padding: 10px 14px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      font-size: 13px;
    }

    details summary {
      cursor: pointer;
      font-weight: 600;
    }

    details pre {
      margin-top: 12px;
      background: #0f1116;
      border-radius: var(--radius-sm);
      padding: 12px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      max-height: 320px;
      overflow: auto;
      color: var(--color-text);
    }

    .alert {
      border-radius: var(--radius-sm);
      padding: 12px 14px;
      font-size: 14px;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .alert-info {
      background: rgba(56, 189, 248, 0.15);
      border: 1px solid rgba(56, 189, 248, 0.35);
      color: var(--color-info);
    }

    .alert-error {
      background: rgba(239, 91, 91, 0.16);
      border: 1px solid rgba(239, 91, 91, 0.35);
      color: var(--color-danger);
    }

    .database-shell {
      display: grid;
      grid-template-columns: 260px 1fr;
      gap: 24px;
      align-items: flex-start;
    }

    .db-table-panel {
      background: var(--color-panel);
      border-radius: var(--radius);
      border: 1px solid var(--color-border);
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      max-height: 640px;
    }

    .db-table-panel header h3 {
      margin: 0;
      font-size: 16px;
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }

    .db-table-panel header p {
      margin: 4px 0 0 0;
      color: var(--color-muted);
      font-size: 12px;
    }

    .db-table-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
      overflow-y: auto;
      scrollbar-width: thin;
    }

    .db-table-entry {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: 1px solid transparent;
      border-radius: var(--radius-sm);
      background: transparent;
      padding: 10px 12px;
      color: var(--color-muted);
      font-weight: 600;
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: background var(--transition), border var(--transition), color var(--transition), transform var(--transition);
      text-align: left;
    }

    .db-table-entry:hover {
      background: rgba(229, 160, 13, 0.12);
      border-color: rgba(229, 160, 13, 0.25);
      color: var(--color-text);
      transform: translateX(2px);
    }

    .db-table-entry.active {
      background: rgba(229, 160, 13, 0.18);
      border-color: rgba(229, 160, 13, 0.35);
      color: var(--color-text);
      box-shadow: 0 12px 28px rgba(229, 160, 13, 0.18);
    }

    .db-table-entry span {
      font-size: 12px;
      color: var(--color-muted);
    }

    .db-content-panel {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .db-card {
      background: var(--color-panel);
      border-radius: var(--radius);
      border: 1px solid var(--color-border);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .db-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 16px;
      flex-wrap: wrap;
    }

    .db-header h3 {
      margin: 0;
      font-size: 18px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .db-header p {
      margin: 4px 0 0 0;
      font-size: 13px;
      color: var(--color-muted);
    }

    .db-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .db-controls input {
      background: rgba(15, 17, 21, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-sm);
      padding: 8px 12px;
      color: var(--color-text);
      min-width: 190px;
    }

    .db-controls input:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .table-container {
      border: 1px solid var(--color-border);
      border-radius: var(--radius-sm);
      overflow: hidden;
      background: rgba(15, 17, 21, 0.7);
      position: relative;
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
      min-width: 440px;
    }

    .data-table th,
    .data-table td {
      padding: 10px 14px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.04);
      text-align: left;
      font-size: 13px;
      vertical-align: top;
    }

    .data-table th {
      position: sticky;
      top: 0;
      background: rgba(27, 31, 38, 0.95);
      backdrop-filter: blur(6px);
      color: var(--color-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 12px;
      z-index: 2;
    }

    .data-table tbody tr:hover td {
      background: rgba(229, 160, 13, 0.06);
    }

    .data-table td {
      color: var(--color-text);
      white-space: pre-wrap;
      word-break: break-word;
    }

    .data-table code {
      background: rgba(15, 17, 21, 0.6);
      border-radius: 4px;
      padding: 2px 4px;
      font-size: 12px;
      color: var(--color-accent-strong);
    }

    .db-sort-button {
      background: none;
      border: none;
      color: inherit;
      font: inherit;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 0;
    }

    .db-sort-button:hover {
      color: var(--color-text);
    }

    .db-sort-button.active {
      color: var(--color-accent);
    }

    .db-filter-panel {
      background: var(--color-panel);
      border-radius: var(--radius);
      border: 1px solid var(--color-border);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .db-filter-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 18px;
    }

    .db-filter-section {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .db-filter-section h4 {
      margin: 0;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--color-muted);
    }

    .db-filter-controls {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .db-filter-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .db-inline-input,
    .db-filter-section select {
      background: rgba(15, 17, 21, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-sm);
      padding: 8px 12px;
      color: var(--color-text);
      min-height: 36px;
    }

    .db-inline-input:disabled,
    .db-filter-section select:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .db-pill-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      min-height: 34px;
    }

    .db-column-option {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      cursor: pointer;
      transition: background var(--transition), border var(--transition), transform var(--transition);
    }

    .db-column-option input {
      accent-color: var(--color-accent);
    }

    .db-column-option:hover {
      background: rgba(229, 160, 13, 0.18);
      border-color: rgba(229, 160, 13, 0.35);
      transform: translateY(-1px);
    }

    .db-chip {
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(15, 17, 21, 0.5);
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 12px;
      color: var(--color-muted);
      cursor: pointer;
      transition: background var(--transition), color var(--transition), border var(--transition), transform var(--transition);
    }

    .db-chip:hover {
      color: var(--color-text);
      border-color: rgba(229, 160, 13, 0.45);
    }

    .db-chip.active {
      background: rgba(229, 160, 13, 0.18);
      color: var(--color-text);
      border-color: rgba(229, 160, 13, 0.45);
      box-shadow: 0 12px 28px rgba(229, 160, 13, 0.15);
    }

    .db-chip[data-state="notNull"].active {
      background: rgba(56, 189, 248, 0.18);
      border-color: rgba(56, 189, 248, 0.35);
      color: var(--color-text);
    }

    .db-chip[data-state="null"].active {
      background: rgba(239, 91, 91, 0.16);
      border-color: rgba(239, 91, 91, 0.35);
      color: var(--color-text);
    }

    .db-empty-state {
      padding: 32px;
      text-align: center;
      color: var(--color-muted);
      font-size: 14px;
    }

    .db-pagination {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
    }

    .db-pagination span {
      color: var(--color-muted);
      font-size: 13px;
    }

    .db-pagination .btn {
      min-width: 110px;
    }

    .db-search-hint {
      color: var(--color-muted);
      font-size: 12px;
    }

    .error-text {
      color: var(--color-danger);
    }

    @media (max-width: 980px) {
      body {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        height: auto;
        flex-direction: row;
        align-items: center;
        gap: 18px;
        overflow-x: auto;
      }

      .nav-list {
        flex-direction: row;
      }

      .sidebar-footer {
        display: none;
      }

      .main {
        padding: 24px;
      }

      .database-shell {
        grid-template-columns: 1fr;
      }

      .db-table-panel {
        max-height: none;
      }

      .db-controls {
        justify-content: flex-start;
        width: 100%;
      }

      .db-filter-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 640px) {
      .main {
        padding: 18px;
      }

      .metrics-grid,
      .panel-grid,
      .option-list {
        grid-template-columns: 1fr;
      }

      .button-row {
        flex-direction: column;
        align-items: stretch;
      }

      .db-controls {
        flex-direction: column;
        align-items: stretch;
      }

      .db-controls input {
        width: 100%;
      }

      .db-pagination {
        flex-direction: column;
        align-items: stretch;
      }

      .page-header {
        flex-direction: column;
        align-items: stretch;
      }

      .db-filter-row {
        flex-direction: column;
        align-items: stretch;
      }
    }
  </style>
</head>
<body>
  <div class="toast-container" id="toast-container"></div>
  <div class="app-shell">
    <aside class="sidebar">
      <div>
        <h1 class="brand">Plex Exporter</h1>
        <p class="brand-sub">Admin control center</p>
      </div>
      <nav class="nav-list">
        <button class="nav-button active" data-view="dashboard">Dashboard</button>
        <button class="nav-button" data-view="config">Configuration</button>
        <button class="nav-button" data-view="logs">Logs</button>
        <button class="nav-button" data-view="database">Database</button>
        <button class="nav-button" data-view="tautulli-sync">Tautulli Sync</button>
        <button class="nav-button" data-view="diagnostics">Diagnostics</button>
      </nav>
      <div class="sidebar-footer">
        <label class="auto-toggle">
          <input type="checkbox" id="auto-refresh-toggle">
          Auto refresh
        </label>
        <div>
          <div>Last update</div>
          <div id="last-updated">not loaded yet</div>
        </div>
      </div>
    </aside>
    <main class="main">
      <header class="page-header">
        <div>
          <h2>Admin dashboard</h2>
          <p id="header-text">System overview and service status in one place.</p>
        </div>
        <div class="header-actions">
          <span class="muted" id="auto-refresh-label">auto refresh off</span>
          <button class="btn" id="refresh-button">Refresh view</button>
        </div>
      </header>

      <section class="view active" id="view-dashboard">
        <div class="metrics-grid">
          <article class="metric-card">
            <h3>Total media</h3>
            <div class="metric-value" id="stat-total-media">-</div>
            <div class="metric-sub">Movies <span id="stat-movie-count">-</span> | Shows <span id="stat-show-count">-</span></div>
          </article>
          <article class="metric-card">
            <h3>Series structure</h3>
            <div class="metric-value" id="stat-season-count">-</div>
            <div class="metric-sub">Episodes <span id="stat-episode-count">-</span> | Cast <span id="stat-cast-count">-</span></div>
          </article>
          <article class="metric-card">
            <h3>Thumbnails</h3>
            <div class="metric-value" id="stat-thumb-total">-</div>
            <div class="metric-sub">Combined media artwork count</div>
          </article>
          <article class="metric-card">
            <h3>Database size</h3>
            <div class="metric-value" id="stat-db-size">-</div>
            <div class="metric-sub" id="stat-db-path">path unknown</div>
          </article>
          <article class="metric-card">
            <h3>Uptime</h3>
            <div class="metric-value" id="stat-uptime">-</div>
            <div class="metric-sub">PID <span id="stat-pid">-</span> | Node <span id="stat-node">-</span></div>
          </article>
        </div>

        <div class="panel-grid">
          <article class="panel">
            <header>
              <div>
                <h3>System status</h3>
                <span>Runtime, memory and host details</span>
              </div>
              <div id="system-status-chip"></div>
            </header>
            <div class="info-list" id="system-status">
              <div class="muted">Loading system status...</div>
            </div>
          </article>
          <article class="panel">
            <header>
              <div>
                <h3>Services</h3>
                <span>TMDB, Tautulli, API auth</span>
              </div>
            </header>
            <div class="info-list" id="service-status">
              <div class="muted">Loading service configuration...</div>
            </div>
          </article>
          <article class="panel">
            <header>
              <div>
                <h3>Series samples</h3>
                <span>Recently indexed series with seasons and cast preview</span>
              </div>
            </header>
            <div class="info-list" id="series-overview">
              <div class="muted">Loading series overview...</div>
            </div>
          </article>
        </div>
      </section>

      <section class="view" id="view-config">
        <article class="card">
          <div>
            <h3>TMDb integration</h3>
            <p>Manage the TMDb API token used for hero enrichment and artwork fetching.</p>
          </div>
          <div class="input-stack">
            <label class="input-label" for="tmdb-token-input">TMDb access token</label>
            <input id="tmdb-token-input" type="password" autocomplete="off" placeholder="TMDb v4 API Read Access Token">
            <div class="muted" id="tmdb-token-status">Loading TMDb status…</div>
            <div class="button-row">
              <button class="btn btn-primary" id="btn-save-tmdb">Save token</button>
              <button class="btn" id="btn-test-tmdb">Test token</button>
              <button class="btn btn-danger" id="btn-clear-tmdb">Remove token</button>
            </div>
            <div class="muted" id="tmdb-test-output">No test executed yet.</div>
          </div>
        </article>
        <article class="card">
          <div>
            <h3>Resend email configuration</h3>
            <p>Manage email delivery settings using Resend for watchlist emails, welcome emails and newsletters.</p>
          </div>
          <div class="input-stack">
            <label class="input-label" for="resend-api-key-input">Resend API key</label>
            <input id="resend-api-key-input" type="password" autocomplete="off" placeholder="re_xxxxxxxxxxxxx">
            <label class="input-label" for="resend-from-email-input">From email address</label>
            <input id="resend-from-email-input" type="email" autocomplete="off" placeholder="no-reply@example.com">
            <div class="muted" id="resend-status">Loading Resend status…</div>
            <label class="input-label" for="resend-test-to-input">Test recipient email</label>
            <input id="resend-test-to-input" type="email" autocomplete="off" placeholder="test@example.com">
            <div class="button-row">
              <button class="btn btn-primary" id="btn-save-resend">Save configuration</button>
              <button class="btn" id="btn-test-resend">Send test email</button>
              <button class="btn btn-danger" id="btn-clear-resend">Remove configuration</button>
            </div>
            <div class="muted" id="resend-test-output">No test executed yet.</div>
          </div>
        </article>
        <article class="card">
          <div>
            <h3>Welcome emails</h3>
            <p>Send onboarding emails manually and inspect recent delivery history.</p>
          </div>
          <div class="input-stack">
            <label class="input-label" for="welcome-email-input">Recipient email</label>
            <input id="welcome-email-input" type="email" autocomplete="off" placeholder="user@example.com">
            <label class="input-label" for="welcome-name-input">Recipient name (optional)</label>
            <input id="welcome-name-input" type="text" autocomplete="off" placeholder="Jane Doe">
            <label class="input-label" for="welcome-url-input">Application URL (optional)</label>
            <input id="welcome-url-input" type="url" autocomplete="off" placeholder="https://app.example.com">
            <div class="button-row">
              <button class="btn" id="btn-check-welcome-email">Check status</button>
              <button class="btn btn-primary" id="btn-send-welcome-email">Send welcome email</button>
              <button class="btn" id="btn-reload-welcome-email">Reload data</button>
              <button class="btn btn-danger" id="btn-clear-welcome-email">Clear history</button>
            </div>
            <div class="muted" id="welcome-email-status">Provide a recipient to send a welcome email.</div>
          </div>
          <div class="info-list">
            <div>
              <strong>Statistics</strong>
              <div id="welcome-email-stats" class="muted">Loading welcome email statistics…</div>
            </div>
            <div>
              <strong>Recent history</strong>
              <div id="welcome-email-history" class="muted">Loading welcome email history…</div>
            </div>
          </div>
        </article>
        <article class="card">
          <div>
            <h3>Configuration snapshot</h3>
            <p>Current backend configuration (sensitive values are masked).</p>
          </div>
          <div id="config-view">
            <div class="muted">Loading configuration...</div>
          </div>
        </article>
      </section>

      <section class="view" id="view-logs">
        <article class="card">
          <div>
            <h3>Runtime logs</h3>
            <p>Recent entries from the in-memory log buffer.</p>
          </div>
          <div class="button-row">
            <label class="input-label" for="log-level">Level</label>
            <select id="log-level">
              <option value="">all levels</option>
              <option value="debug">debug</option>
              <option value="info">info</option>
              <option value="warn">warn</option>
              <option value="error">error</option>
            </select>
            <label class="input-label" for="log-limit">Limit</label>
            <input type="number" id="log-limit" min="10" max="500" value="150">
            <button class="btn" id="btn-refresh-logs">Refresh</button>
            <button class="btn" id="btn-clear-logs">Clear logs</button>
          </div>
          <div class="muted" id="log-summary">No logs loaded yet.</div>
          <div class="log-view" id="log-view">Press refresh to load logs.</div>
        </article>
      </section>

      <section class="view" id="view-database">
        <div class="database-shell">
          <aside class="db-table-panel">
            <header>
              <h3>Tables</h3>
              <p>Browse the SQLite schema and sample records.</p>
            </header>
            <div class="db-table-list" id="db-table-list">
              <div class="muted">Loading tables...</div>
            </div>
            <button class="btn" id="db-reload-schema">Reload tables</button>
          </aside>
          <div class="db-content-panel">
            <article class="db-card db-filter-panel">
              <div class="db-filter-grid">
                <div class="db-filter-section">
                  <h4>Columns</h4>
                  <div id="db-column-list" class="db-pill-list">
                    <div class="muted">No columns loaded yet.</div>
                  </div>
                </div>
                <div class="db-filter-section" id="db-primary-key-section">
                  <h4>Primary key jump</h4>
                  <div class="db-filter-controls">
                    <div class="db-filter-row">
                      <input type="text" id="db-pk-input" class="db-inline-input" placeholder="Enter value" autocomplete="off" disabled>
                      <button class="btn" id="db-apply-pk" disabled>Jump</button>
                      <button class="btn" id="db-clear-pk" disabled>Clear</button>
                    </div>
                    <div class="db-search-hint" id="db-pk-hint">No primary key detected.</div>
                  </div>
                </div>
                <div class="db-filter-section" id="db-date-section">
                  <h4>Date range</h4>
                  <div class="db-filter-controls">
                    <select id="db-date-column" disabled>
                      <option value="">No date columns</option>
                    </select>
                    <div class="db-filter-row">
                      <input type="datetime-local" id="db-date-from" class="db-inline-input" disabled>
                      <input type="datetime-local" id="db-date-to" class="db-inline-input" disabled>
                    </div>
                    <div class="db-filter-row">
                      <button class="btn" id="db-apply-date" disabled>Apply</button>
                      <button class="btn" id="db-clear-date" disabled>Clear</button>
                    </div>
                  </div>
                </div>
                <div class="db-filter-section" id="db-enum-section">
                  <h4>Quick filters</h4>
                  <div id="db-enum-filters" class="db-pill-list">
                    <div class="muted">No quick filters available.</div>
                  </div>
                </div>
                <div class="db-filter-section" id="db-null-section">
                  <h4>Null filters</h4>
                  <div id="db-null-filters" class="db-pill-list">
                    <div class="muted">No nullable columns.</div>
                  </div>
                </div>
              </div>
            </article>
            <article class="db-card">
              <div class="db-header">
                <div>
                  <h3 id="db-active-table">Select a table</h3>
                  <p id="db-table-meta">Choose a table from the list to inspect its rows.</p>
                </div>
                <div class="db-controls">
                  <input type="text" id="db-search-input" placeholder="Search selected table" autocomplete="off" disabled>
                  <button class="btn" id="db-search-button" disabled>Search</button>
                  <button class="btn" id="db-clear-search" disabled>Clear</button>
                  <button class="btn" id="db-refresh-table" disabled>Refresh</button>
                </div>
              </div>
              <div class="db-search-hint" id="db-search-hint">No table selected.</div>
              <div class="table-container">
                <table class="data-table">
                  <thead>
                    <tr id="db-table-head"></tr>
                  </thead>
                  <tbody id="db-table-body">
                    <tr>
                      <td class="db-empty-state" colspan="1">Select a table to view rows.</td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <div class="db-pagination">
                <button class="btn" id="db-prev-page" disabled>Previous</button>
                <span id="db-page-info">0 – 0 of 0</span>
                <button class="btn" id="db-next-page" disabled>Next</button>
              </div>
            </article>
          </div>
        </div>
      </section>

      <section class="view" id="view-tautulli-sync">
        <div class="panel-grid">
          <!-- Tautulli Connection Panel -->
          <article class="panel">
            <h3>Tautulli-Verbindung</h3>
            <p>Tautulli API-Verbindungseinstellungen konfigurieren</p>
            <div id="tautulli-config-content">
              <label class="input-label">Tautulli URL</label>
              <input type="text" id="tautulli-url" placeholder="https://tautulli.example.com" style="width: 100%; margin-bottom: 4px;">
              <small class="muted" style="display: block; margin-bottom: 12px;">
                Nur die Basis-URL eingeben (z.B. https://tautulli.dinspel.eu). /api/v2 nicht angeben - wird automatisch hinzugefügt.
              </small>
              <label class="input-label">API-Schlüssel</label>
              <input type="password" id="tautulli-api-key" placeholder="Ihren Tautulli API-Schlüssel eingeben" style="width: 100%; margin-bottom: 12px;">
              <label class="input-label">
                <input type="checkbox" id="show-api-key">
                API-Schlüssel anzeigen
              </label>
              <div style="margin-top: 12px;">
                <button class="btn-primary" id="btn-save-tautulli-config">Konfiguration speichern</button>
                <button class="btn" id="btn-test-connection" style="margin-left: 8px;">Verbindung testen</button>
              </div>
              <div id="tautulli-config-status" class="muted" style="margin-top: 16px;"></div>
            </div>
          </article>

          <!-- Library Selection Panel -->
          <article class="panel">
            <h3>Bibliotheks-Konfiguration</h3>
            <p>Wählen Sie aus, welche Tautulli-Bibliotheken synchronisiert werden sollen</p>
            <div id="library-config-content">
              <button class="btn" id="btn-load-libraries">Verfügbare Bibliotheken laden</button>
              <div id="library-list" class="muted" style="margin-top: 16px;">Klicken Sie auf "Verfügbare Bibliotheken laden", um diese von Tautulli abzurufen</div>
              <div id="selected-libraries" style="margin-top: 16px; display: none;">
                <h4>Ausgewählte Bibliotheken</h4>
                <div id="selected-libraries-list"></div>
                <button class="btn-primary" id="btn-save-libraries" style="margin-top: 12px;">Konfiguration speichern</button>
              </div>
            </div>
          </article>

          <!-- Manual Sync Panel -->
          <article class="panel">
            <h3>Manueller Sync</h3>
            <p>Einen einmaligen Synchronisationsvorgang auslösen</p>
            <div class="alert alert-info" style="margin-bottom: 16px;">
              <strong>Sync-Ablauf:</strong> Zuerst werden Metadaten und IDs (TMDb, IMDb) von Tautulli abgerufen, dann werden bei aktivierter Option die Bilder lokal gespeichert, und anschließend optional TMDb-Anreicherung durchgeführt.
            </div>
            <div class="option-list">
              <label class="checkbox">
                <input type="checkbox" id="sync-incremental" checked>
                <div>
                  <strong>Inkrementell</strong>
                  <div class="muted" style="font-size: 11px; margin-top: 2px;">Nur geänderte Einträge synchronisieren</div>
                </div>
              </label>
              <label class="checkbox">
                <input type="checkbox" id="sync-covers" checked>
                <div>
                  <strong>Covers von Tautulli herunterladen</strong>
                  <div class="muted" style="font-size: 11px; margin-top: 2px;">Poster und Backdrops lokal speichern (empfohlen für manuellen Sync)</div>
                </div>
              </label>
              <label class="checkbox">
                <input type="checkbox" id="sync-tmdb" checked>
                <div>
                  <strong>Mit TMDb anreichern</strong>
                  <div class="muted" style="font-size: 11px; margin-top: 2px;">Zusätzliche Metadaten und Bewertungen von TMDb abrufen</div>
                </div>
              </label>
            </div>
            <button class="btn-primary" id="btn-start-sync">Sync starten</button>
            <div id="sync-status" class="muted" style="margin-top: 16px;"></div>
          </article>

          <!-- Schedule Configuration Panel -->
          <article class="panel">
            <h3>Automatischer Sync</h3>
            <p>Automatische tägliche Synchronisation konfigurieren</p>
            <div class="alert alert-info" style="margin-bottom: 16px;">
              <strong>Hinweis:</strong> Bei automatischen Syncs werden standardmäßig keine Bilder heruntergeladen, um die Performance zu optimieren. Für Bild-Downloads verwenden Sie bitte den manuellen Sync.
            </div>
            <div id="schedule-config">
              <label class="input-label">Job-Typ</label>
              <select id="schedule-job-type">
                <option value="tautulli_sync">Tautulli Sync</option>
                <option value="cover_update">Cover Update</option>
              </select>
              <label class="input-label">Cron-Ausdruck</label>
              <input type="text" id="schedule-cron" placeholder="0 3 * * *" value="0 3 * * *">
              <small class="muted">Beispiel: "0 3 * * *" = Täglich um 3:00 Uhr</small>
              <label class="input-label">
                <input type="checkbox" id="schedule-enabled" checked>
                Aktiviert
              </label>
              <button class="btn" id="btn-save-schedule" style="margin-top: 12px;">Zeitplan speichern</button>
            </div>
            <div id="current-schedules" style="margin-top: 16px;">
              <h4>Aktuelle Zeitpläne</h4>
              <div id="schedules-list" class="muted">Lädt...</div>
            </div>
          </article>

          <!-- Sync Statistics Panel -->
          <article class="panel">
            <h3>Konfigurierte Bibliotheken</h3>
            <div id="library-sections-list" class="muted">Lädt...</div>
          </article>
        </div>
      </section>

      <section class="view" id="view-diagnostics">
        <div class="panel-grid">
          <article class="panel">
            <header>
              <div>
                <h3>Tautulli test</h3>
                <span>Check API connectivity and list libraries.</span>
              </div>
            </header>
            <div class="info-list">
              <button class="btn" id="btn-test-tautulli">Run test</button>
              <div class="muted" id="tautulli-output">No test executed yet.</div>
            </div>
          </article>
          <article class="panel">
            <header>
              <div>
                <h3>Database test</h3>
                <span>Verify SQLite access and record count.</span>
              </div>
            </header>
            <div class="info-list">
              <button class="btn" id="btn-test-db">Run test</button>
              <div class="muted" id="db-output">No test executed yet.</div>
            </div>
          </article>
          <article class="panel">
            <header>
              <div>
                <h3>Resend email test</h3>
                <span>Send a test email to verify Resend configuration.</span>
              </div>
            </header>
            <div class="info-list">
              <label class="input-label" for="resend-test-email">Test recipient email</label>
              <input type="email" id="resend-test-email" placeholder="test@example.com">
              <button class="btn" id="btn-test-resend-diag">Send test email</button>
              <div class="muted" id="resend-diag-output">No test executed yet.</div>
            </div>
          </article>
        </div>
      </section>
    </main>
  </div>
  <script>
    (() => {
      const API_BASE = "/admin/api";
      const WELCOME_EMAIL_API_BASE = "/api/welcome-email";
      const DASHBOARD_INTERVAL = 30000;
      const DB_PAGE_SIZE = 25;
      const numberFormatter = new Intl.NumberFormat("de-DE");
      const toastRoot = document.getElementById("toast-container");

      const elements = {
        navButtons: Array.from(document.querySelectorAll(".nav-button")),
        views: {
          dashboard: document.getElementById("view-dashboard"),
          config: document.getElementById("view-config"),
          logs: document.getElementById("view-logs"),
          database: document.getElementById("view-database"),
          "tautulli-sync": document.getElementById("view-tautulli-sync"),
          diagnostics: document.getElementById("view-diagnostics"),
        },
        refreshButton: document.getElementById("refresh-button"),
        autoToggle: document.getElementById("auto-refresh-toggle"),
        autoLabel: document.getElementById("auto-refresh-label"),
        lastUpdated: document.getElementById("last-updated"),
        headerText: document.getElementById("header-text"),
        statTotalMedia: document.getElementById("stat-total-media"),
        statMovieCount: document.getElementById("stat-movie-count"),
        statShowCount: document.getElementById("stat-show-count"),
        statSeasonCount: document.getElementById("stat-season-count"),
        statEpisodeCount: document.getElementById("stat-episode-count"),
        statCastCount: document.getElementById("stat-cast-count"),
        statThumbTotal: document.getElementById("stat-thumb-total"),
        statDbSize: document.getElementById("stat-db-size"),
        statDbPath: document.getElementById("stat-db-path"),
        statUptime: document.getElementById("stat-uptime"),
        statPid: document.getElementById("stat-pid"),
        statNode: document.getElementById("stat-node"),
        systemStatusChip: document.getElementById("system-status-chip"),
        systemStatus: document.getElementById("system-status"),
        serviceStatus: document.getElementById("service-status"),
        seriesOverview: document.getElementById("series-overview"),
        configView: document.getElementById("config-view"),
        tmdbTokenInput: document.getElementById("tmdb-token-input"),
        tmdbTokenStatus: document.getElementById("tmdb-token-status"),
        tmdbSaveButton: document.getElementById("btn-save-tmdb"),
        tmdbTestButton: document.getElementById("btn-test-tmdb"),
        tmdbClearButton: document.getElementById("btn-clear-tmdb"),
        tmdbTestOutput: document.getElementById("tmdb-test-output"),
        resendApiKeyInput: document.getElementById("resend-api-key-input"),
        resendFromEmailInput: document.getElementById("resend-from-email-input"),
        resendTestToInput: document.getElementById("resend-test-to-input"),
        resendStatus: document.getElementById("resend-status"),
        resendSaveButton: document.getElementById("btn-save-resend"),
        resendTestButton: document.getElementById("btn-test-resend"),
        resendClearButton: document.getElementById("btn-clear-resend"),
        resendTestOutput: document.getElementById("resend-test-output"),
        resendTestEmail: document.getElementById("resend-test-email"),
        resendTestButtonDiag: document.getElementById("btn-test-resend-diag"),
        resendDiagOutput: document.getElementById("resend-diag-output"),
        welcomeEmailInput: document.getElementById("welcome-email-input"),
        welcomeNameInput: document.getElementById("welcome-name-input"),
        welcomeUrlInput: document.getElementById("welcome-url-input"),
        welcomeStatus: document.getElementById("welcome-email-status"),
        welcomeStats: document.getElementById("welcome-email-stats"),
        welcomeHistory: document.getElementById("welcome-email-history"),
        welcomeSendButton: document.getElementById("btn-send-welcome-email"),
        welcomeCheckButton: document.getElementById("btn-check-welcome-email"),
        welcomeReloadButton: document.getElementById("btn-reload-welcome-email"),
        welcomeClearButton: document.getElementById("btn-clear-welcome-email"),
        logView: document.getElementById("log-view"),
        logSummary: document.getElementById("log-summary"),
        logLevel: document.getElementById("log-level"),
        logLimit: document.getElementById("log-limit"),
        refreshLogs: document.getElementById("btn-refresh-logs"),
        clearLogs: document.getElementById("btn-clear-logs"),
        tautulliOutput: document.getElementById("tautulli-output"),
        tautulliButton: document.getElementById("btn-test-tautulli"),
        dbOutput: document.getElementById("db-output"),
        dbButton: document.getElementById("btn-test-db"),
        dbReloadSchema: document.getElementById("db-reload-schema"),
        dbTableList: document.getElementById("db-table-list"),
        dbColumnList: document.getElementById("db-column-list"),
        dbActiveTable: document.getElementById("db-active-table"),
        dbTableMeta: document.getElementById("db-table-meta"),
        dbSearchInput: document.getElementById("db-search-input"),
        dbSearchButton: document.getElementById("db-search-button"),
        dbClearSearch: document.getElementById("db-clear-search"),
        dbRefreshTable: document.getElementById("db-refresh-table"),
        dbSearchHint: document.getElementById("db-search-hint"),
        dbPkInput: document.getElementById("db-pk-input"),
        dbPkApply: document.getElementById("db-apply-pk"),
        dbPkClear: document.getElementById("db-clear-pk"),
        dbPkHint: document.getElementById("db-pk-hint"),
        dbDateColumn: document.getElementById("db-date-column"),
        dbDateFrom: document.getElementById("db-date-from"),
        dbDateTo: document.getElementById("db-date-to"),
        dbDateApply: document.getElementById("db-apply-date"),
        dbDateClear: document.getElementById("db-clear-date"),
        dbEnumFilters: document.getElementById("db-enum-filters"),
        dbNullFilters: document.getElementById("db-null-filters"),
        dbTableHead: document.getElementById("db-table-head"),
        dbTableBody: document.getElementById("db-table-body"),
        dbPrevPage: document.getElementById("db-prev-page"),
        dbNextPage: document.getElementById("db-next-page"),
        dbPageInfo: document.getElementById("db-page-info"),
      };

      const state = {
        currentView: "dashboard",
        autoRefresh: false,
        autoTimer: null,
        tmdbStatus: null,
        resendStatus: null,
        welcomeEmail: {
          stats: null,
          loadingStats: false,
          history: [],
          loadingHistory: false,
        },
        database: {
          tables: [],
          tablesError: null,
          loadingTables: false,
          activeTable: null,
          schema: [],
          columns: [],
          rows: [],
          pagination: {
            limit: DB_PAGE_SIZE,
            offset: 0,
            total: 0,
            hasMore: false,
          },
          search: "",
          orderBy: null,
          direction: "ASC",
          searchableColumns: [],
          loadingRows: false,
          rowsError: null,
          filterOptions: {
            primaryKey: null,
            dateColumns: [],
            enumValues: {},
            nullableColumns: [],
          },
          filters: {
            equals: {},
            nulls: {},
            dateRange: null,
            primaryKeyValue: null,
          },
          selectedColumns: [],
        },
      };

      const viewDescriptions = {
        dashboard: "System overview and service status in one place.",
        config: "Manage TMDb credentials and inspect the backend configuration snapshot.",
        logs: "Inspect the in-memory log buffer. Useful for quick diagnostics.",
        database: "Inspect the SQLite database contents directly from the admin panel.",
        "tautulli-sync": "Manage Tautulli synchronization, library selection, and sync schedules.",
        diagnostics: "Connectivity checks for Tautulli and database services.",
      };

      const viewLoaders = {
        dashboard: loadDashboard,
        config: loadConfig,
        logs: loadLogs,
        database: async () => {
          if (state.database.tables.length === 0) {
            await loadDatabaseTables(true);
          } else {
            renderDatabaseExplorer();
            await loadDatabaseRows();
          }
        },
        "tautulli-sync": async () => {
          await loadTautulliConfig();
          await loadLibrarySections();
          await loadSchedules();
        },
        diagnostics: async () => {},
      };

      function escapeHtml(value) {
        return String(value)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function getErrorMessage(error, fallback = "An unexpected error occurred.") {
        if (error instanceof Error && error.message) {
          return error.message;
        }
        if (typeof error === "string" && error) {
          return error;
        }
        if (error && typeof error === "object" && "message" in error && error.message) {
          return String(error.message);
        }
        return fallback;
      }

      async function fetchJson(url, options) {
        const config = Object.assign({ headers: {} }, options);
        if (config.body && !config.headers["Content-Type"]) {
          config.headers["Content-Type"] = "application/json";
        }
        const response = await fetch(url, config);
        const text = await response.text();
        let data = {};
        if (text) {
          try {
            data = JSON.parse(text);
          } catch {
            data = { message: text };
          }
        }
        if (!response.ok) {
          const message = data.message || data.error || response.statusText || "request failed";
          throw new Error(message);
      }
      return data;
    }

    function renderDatabaseExplorer() {
      renderDatabaseTableList();
      renderDatabaseFilters();
      renderDatabaseContent();
    }

    function renderDatabaseTableList() {
      if (!elements.dbTableList) return;
        const { tables, loadingTables, tablesError, activeTable } = state.database;

        if (elements.dbReloadSchema) {
          elements.dbReloadSchema.disabled = loadingTables;
        }

        if (loadingTables) {
          elements.dbTableList.innerHTML = '<div class="muted">Loading tables…</div>';
          return;
        }

        if (tablesError) {
          elements.dbTableList.innerHTML = `<div class="error-text">${escapeHtml(tablesError)}</div>`;
          return;
        }

        if (!tables.length) {
          elements.dbTableList.innerHTML = '<div class="muted">No tables found in the database.</div>';
          return;
        }

        elements.dbTableList.innerHTML = tables
          .map((table) => {
            const isActive = table.name === activeTable;
            const count =
              typeof table.rowCount === "number" && Number.isFinite(table.rowCount)
                ? numberFormatter.format(table.rowCount)
                : "—";
            return `<button class="db-table-entry${isActive ? " active" : ""}" data-table-name="${escapeHtml(table.name)}">
              <span>${escapeHtml(table.name)}</span>
              <span>${count}</span>
            </button>`;
          })
          .join("");
      }

      function renderDatabaseFilters() {
        const {
          loadingTables,
          loadingRows,
          schema,
          selectedColumns,
          filterOptions,
          filters,
        } = state.database;

        if (elements.dbColumnList) {
          if (loadingTables) {
            elements.dbColumnList.innerHTML = '<div class="muted">Loading columns…</div>';
          } else if (!schema.length) {
            elements.dbColumnList.innerHTML = '<div class="muted">Columns unavailable.</div>';
          } else {
            const selectedSet = new Set(
              selectedColumns.length > 0
                ? selectedColumns
                : schema.map(column => column.name),
            );
            elements.dbColumnList.innerHTML = schema
              .map(column => {
                const checked = selectedSet.has(column.name) ? 'checked' : '';
                const disabled = loadingRows ? 'disabled' : '';
                return `
                  <label class="db-column-option">
                    <input type="checkbox" value="${escapeHtml(column.name)}" ${checked} ${disabled}>
                    ${escapeHtml(column.name)}
                  </label>
                `;
              })
              .join("");

            elements.dbColumnList
              .querySelectorAll('input[type="checkbox"]')
              .forEach((input) => {
                input.addEventListener('change', handleColumnSelectionChange);
              });
          }
        }

        const primaryKeyColumn = filterOptions?.primaryKey ?? null;
        const hasPrimaryKey = Boolean(primaryKeyColumn);
        const pkValue = filters?.primaryKeyValue ? String(filters.primaryKeyValue) : '';

        if (elements.dbPkInput) {
          elements.dbPkInput.disabled = !hasPrimaryKey || loadingTables;
          elements.dbPkInput.placeholder = hasPrimaryKey
            ? `Value for ${primaryKeyColumn}`
            : 'Enter value';
          if (!document.activeElement || document.activeElement !== elements.dbPkInput) {
            elements.dbPkInput.value = pkValue;
          }
        }

        const pkInputValue = elements.dbPkInput ? elements.dbPkInput.value : pkValue;
        const pkInputTrimmed = pkInputValue.trim();

        if (elements.dbPkApply) {
          elements.dbPkApply.disabled =
            !hasPrimaryKey || loadingTables || loadingRows || pkInputTrimmed.length === 0;
        }

        if (elements.dbPkClear) {
          elements.dbPkClear.disabled =
            !hasPrimaryKey || loadingTables || (
              pkInputTrimmed.length === 0 && (!filters?.primaryKeyValue || String(filters.primaryKeyValue).trim().length === 0)
            );
        }

        if (elements.dbPkHint) {
          elements.dbPkHint.textContent = hasPrimaryKey
            ? `Jump positions results using column ${primaryKeyColumn}.`
            : 'No primary key detected.';
        }

        const dateColumns = Array.isArray(filterOptions?.dateColumns)
          ? filterOptions.dateColumns
          : [];
        const activeDateColumn = filters?.dateRange?.column ?? '';

        if (elements.dbDateColumn) {
          const options = dateColumns.length
            ? ['<option value="">Select column…</option>',
              ...dateColumns.map(column => `<option value="${escapeHtml(column)}">${escapeHtml(column)}</option>`)
            ].join('')
            : '<option value="">No date columns</option>';
          elements.dbDateColumn.innerHTML = options;
          elements.dbDateColumn.disabled = dateColumns.length === 0 || loadingTables;
          if (dateColumns.includes(activeDateColumn)) {
            elements.dbDateColumn.value = activeDateColumn;
          } else {
            elements.dbDateColumn.value = '';
          }
        }

        const hasDateSelection = Boolean(activeDateColumn && dateColumns.includes(activeDateColumn));

        if (elements.dbDateFrom) {
          elements.dbDateFrom.value = filters?.dateRange?.from ?? '';
          elements.dbDateFrom.disabled = !hasDateSelection || loadingRows || loadingTables;
        }

        if (elements.dbDateTo) {
          elements.dbDateTo.value = filters?.dateRange?.to ?? '';
          elements.dbDateTo.disabled = !hasDateSelection || loadingRows || loadingTables;
        }

        if (elements.dbDateApply) {
          elements.dbDateApply.disabled = !hasDateSelection || loadingRows || loadingTables;
        }

        if (elements.dbDateClear) {
          const hasValues = Boolean(filters?.dateRange?.from || filters?.dateRange?.to);
          elements.dbDateClear.disabled = (!hasDateSelection && !hasValues) || loadingTables;
        }

        if (elements.dbEnumFilters) {
          const enumEntries = Object.entries(filterOptions?.enumValues ?? {});
          if (!enumEntries.length) {
            elements.dbEnumFilters.innerHTML = '<div class="muted">No quick filters available.</div>';
          } else {
            elements.dbEnumFilters.innerHTML = enumEntries
              .map(([column, values]) => {
                const activeValue = filters?.equals?.[column] ?? null;
                const chips = values
                  .map(({ value, count }) => {
                    const encodedValue = encodeURIComponent(value);
                    const isActive = activeValue !== null && String(activeValue) === value;
                    return `<button class="db-chip${isActive ? ' active' : ''}" data-enum-column="${escapeHtml(column)}" data-enum-value="${encodedValue}">
                      ${escapeHtml(value)} <span class="muted">(${numberFormatter.format(count)})</span>
                    </button>`;
                  })
                  .join('');
                const clearButton = `<button class="db-chip" data-enum-column="${escapeHtml(column)}" data-enum-clear="1">Clear</button>`;
                return `<div class="db-filter-section">
                  <h4>${escapeHtml(column)}</h4>
                  <div class="db-pill-list">${chips}${clearButton}</div>
                </div>`;
              })
              .join('');

            elements.dbEnumFilters
              .querySelectorAll('[data-enum-column]')
              .forEach((button) => {
                button.addEventListener('click', handleEnumFilterClick);
              });
          }
        }

        if (elements.dbNullFilters) {
          const nullableColumns = filterOptions?.nullableColumns ?? [];
          if (!nullableColumns.length) {
            elements.dbNullFilters.innerHTML = '<div class="muted">No nullable columns.</div>';
          } else {
            elements.dbNullFilters.innerHTML = nullableColumns
              .map(column => {
                const active = filters?.nulls?.[column] ?? null;
                const nullButton = `<button class="db-chip${active === 'null' ? ' active' : ''}" data-null-column="${escapeHtml(column)}" data-state="null">IS NULL</button>`;
                const notNullButton = `<button class="db-chip${active === 'notNull' ? ' active' : ''}" data-null-column="${escapeHtml(column)}" data-state="notNull">NOT NULL</button>`;
                const clearButton = `<button class="db-chip" data-null-column="${escapeHtml(column)}" data-state="clear">Clear</button>`;
                return `<div class="db-filter-section">
                  <h4>${escapeHtml(column)}</h4>
                  <div class="db-pill-list">${nullButton}${notNullButton}${clearButton}</div>
                </div>`;
              })
              .join('');

            elements.dbNullFilters
              .querySelectorAll('[data-null-column]')
              .forEach((button) => {
                button.addEventListener('click', handleNullFilterClick);
              });
          }
        }

        updatePrimaryKeyButtonState();
        updateDateControlState();
      }

      function renderDatabaseContent() {
        const {
          activeTable,
          columns,
          rows,
          pagination,
          loadingRows,
          rowsError,
          search,
          searchableColumns,
          orderBy,
          direction,
        } = state.database;
        const loadingTables = state.database.loadingTables;

        if (elements.dbActiveTable) {
          elements.dbActiveTable.textContent = activeTable ?? "Select a table";
        }

        if (elements.dbTableMeta) {
          if (loadingTables) {
            elements.dbTableMeta.textContent = "Loading tables…";
          } else if (!activeTable) {
            elements.dbTableMeta.textContent = "Choose a table from the list to inspect its rows.";
          } else if (loadingRows) {
            elements.dbTableMeta.textContent = "Loading rows…";
          } else if (rowsError) {
            elements.dbTableMeta.textContent = rowsError;
          } else {
            const total = pagination.total ?? 0;
            const from = total === 0 ? 0 : pagination.offset + 1;
            const to = pagination.offset + rows.length;
            const formatted = numberFormatter.format(total);
            elements.dbTableMeta.textContent = `${formatted} rows total · showing ${from}–${to}`;
          }
        }

        if (elements.dbSearchInput) {
          elements.dbSearchInput.value = search;
          elements.dbSearchInput.disabled =
            loadingTables || !activeTable || searchableColumns.length === 0 || loadingRows;
          elements.dbSearchInput.placeholder = !activeTable
            ? "Search selected table"
            : searchableColumns.length > 0
              ? `Search ${searchableColumns.join(", ")}`
              : "No searchable columns";
        }

        if (elements.dbSearchButton) {
          elements.dbSearchButton.disabled =
            loadingTables || !activeTable || searchableColumns.length === 0 || loadingRows;
        }

        if (elements.dbClearSearch) {
          elements.dbClearSearch.disabled =
            loadingTables || !activeTable || (search === "" && searchableColumns.length === 0) || loadingRows;
        }

        if (elements.dbRefreshTable) {
          elements.dbRefreshTable.disabled = loadingTables || !activeTable || loadingRows;
        }

        if (elements.dbSearchHint) {
          if (loadingTables) {
            elements.dbSearchHint.textContent = "Loading tables…";
          } else if (!activeTable) {
            elements.dbSearchHint.textContent = "No table selected.";
          } else if (searchableColumns.length === 0) {
            elements.dbSearchHint.textContent = "This table has no text columns to search.";
          } else {
            elements.dbSearchHint.textContent = `Searchable columns: ${searchableColumns.join(", ")}`;
          }
        }

        if (elements.dbTableHead) {
          if (loadingTables || !columns.length) {
            elements.dbTableHead.innerHTML = "";
          } else {
            elements.dbTableHead.innerHTML = columns
              .map((column) => {
                const isActive = orderBy === column.name;
                const indicator = isActive ? (direction === "DESC" ? "▼" : "▲") : "";
                return `<th><button type="button" class="db-sort-button${isActive ? " active" : ""}" data-column="${escapeHtml(column.name)}">${escapeHtml(column.name)}${indicator ? ` <span class="muted">${indicator}</span>` : ""}</button></th>`;
              })
              .join("");
          }
        }

        if (elements.dbTableBody) {
          const columnCount = Math.max(columns.length, 1);
          if (loadingTables || !activeTable) {
            elements.dbTableBody.innerHTML = `<tr><td class="db-empty-state" colspan="${columnCount}">Select a table to view rows.</td></tr>`;
          } else if (loadingRows) {
            elements.dbTableBody.innerHTML = `<tr><td colspan="${columnCount}" class="muted">Loading rows…</td></tr>`;
          } else if (rowsError) {
            elements.dbTableBody.innerHTML = `<tr><td colspan="${columnCount}" class="error-text">${escapeHtml(rowsError)}</td></tr>`;
          } else if (rows.length === 0) {
            elements.dbTableBody.innerHTML = `<tr><td colspan="${columnCount}" class="muted">No rows for the current selection.</td></tr>`;
          } else {
            elements.dbTableBody.innerHTML = rows
              .map(
                row =>
                  `<tr>${columns.map(column => `<td>${renderTableCell(row[column.name])}</td>`).join("")}</tr>`,
              )
              .join("");
          }
        }

        if (elements.dbPageInfo) {
          if (loadingTables || !activeTable) {
            elements.dbPageInfo.textContent = "0 – 0 of 0";
          } else {
            const total = pagination.total ?? 0;
            const from = total === 0 ? 0 : pagination.offset + 1;
            const to = pagination.offset + rows.length;
            const formatted = numberFormatter.format(total);
            elements.dbPageInfo.textContent = `${from} – ${to} of ${formatted}`;
          }
        }

        if (elements.dbPrevPage) {
          elements.dbPrevPage.disabled =
            loadingTables || !activeTable || loadingRows || pagination.offset <= 0;
        }

        if (elements.dbNextPage) {
          const hasMore =
            pagination.hasMore ??
            (pagination.offset + pagination.limit < (pagination.total ?? 0));
          elements.dbNextPage.disabled =
            loadingTables || !activeTable || loadingRows || !hasMore;
        }
      }

      function renderTableCell(value) {
        if (value === null || value === undefined) {
          return '<span class="muted">NULL</span>';
        }
        if (typeof value === "object") {
          try {
            return `<code>${escapeHtml(JSON.stringify(value))}</code>`;
          } catch {
            return `<code>${escapeHtml(String(value))}</code>`;
          }
        }
        const text = String(value);
        if (text.length > 180) {
          const preview = text.slice(0, 180);
          return `<span title="${escapeHtml(text)}">${escapeHtml(preview)}&hellip;</span>`;
        }
        return escapeHtml(text);
      }

      function handleColumnSelectionChange(event) {
        const input = event.target instanceof HTMLInputElement ? event.target : null;
        if (!input) return;
        const column = input.value;
        if (!column) return;
        const schemaNames = state.database.schema.map(col => col.name);
        if (!schemaNames.includes(column)) {
          return;
        }

        const nextSelection = new Set(
          state.database.selectedColumns.length > 0
            ? state.database.selectedColumns
            : schemaNames,
        );

        if (input.checked) {
          nextSelection.add(column);
        } else {
          if (nextSelection.size <= 1) {
            input.checked = true;
            showToast("At least one column must remain visible.", "info");
            return;
          }
          nextSelection.delete(column);
        }

        state.database.selectedColumns = Array.from(nextSelection);
        state.database.pagination.offset = 0;
        loadDatabaseRows().catch(err => showToast(err.message, "error"));
      }

      function handleEnumFilterClick(event) {
        const button = event.currentTarget instanceof HTMLElement ? event.currentTarget : null;
        if (!button) return;
        const column = button.dataset.enumColumn;
        if (!column) return;

        const equalsFilters = Object.assign({}, state.database.filters.equals ?? {});

        let changed = false;

        if (button.dataset.enumClear === '1') {
          if (equalsFilters[column] !== undefined) {
            delete equalsFilters[column];
            changed = true;
          }
        } else if (button.dataset.enumValue) {
          const value = decodeURIComponent(button.dataset.enumValue);
          if (equalsFilters[column] === value) {
            delete equalsFilters[column];
          } else {
            equalsFilters[column] = value;
          }
          changed = true;
        }

        if (!changed) {
          return;
        }

        state.database.filters.equals = equalsFilters;
        state.database.pagination.offset = 0;
        loadDatabaseRows().catch(err => showToast(err.message, "error"));
      }

      function handleNullFilterClick(event) {
        const button = event.currentTarget instanceof HTMLElement ? event.currentTarget : null;
        if (!button) return;
        const column = button.dataset.nullColumn;
        if (!column) return;
        const mode = button.dataset.state;
        const nullFilters = Object.assign({}, state.database.filters.nulls ?? {});

        let changed = false;

        if (mode === 'clear') {
          if (nullFilters[column]) {
            delete nullFilters[column];
            changed = true;
          }
        } else if (mode === 'null' || mode === 'notNull') {
          if (nullFilters[column] === mode) {
            delete nullFilters[column];
          } else {
            nullFilters[column] = mode;
          }
          changed = true;
        }

        if (!changed) {
          return;
        }

        state.database.filters.nulls = nullFilters;
        state.database.pagination.offset = 0;
        loadDatabaseRows().catch(err => showToast(err.message, "error"));
      }

      function updatePrimaryKeyButtonState() {
        const hasPrimaryKey = Boolean(state.database.filterOptions.primaryKey);
        const loading = state.database.loadingTables || state.database.loadingRows;
        const inputValue = elements.dbPkInput ? elements.dbPkInput.value.trim() : "";
        const appliedValue = state.database.filters.primaryKeyValue
          ? String(state.database.filters.primaryKeyValue).trim()
          : "";

        if (elements.dbPkApply) {
          elements.dbPkApply.disabled = !hasPrimaryKey || loading || inputValue.length === 0;
        }

        if (elements.dbPkClear) {
          elements.dbPkClear.disabled =
            !hasPrimaryKey || loading || (inputValue.length === 0 && appliedValue.length === 0);
        }
      }

      function handleApplyPrimaryKey() {
        if (!state.database.filterOptions.primaryKey) {
          showToast("No primary key available for this table.", "info");
          return;
        }
        if (!elements.dbPkInput) return;
        const value = elements.dbPkInput.value.trim();
        if (!value) {
          showToast("Enter a primary key value first.", "info");
          return;
        }
        state.database.filters.primaryKeyValue = value;
        state.database.pagination.offset = 0;
        updatePrimaryKeyButtonState();
        loadDatabaseRows().catch(err => showToast(err.message, "error"));
      }

      function handleClearPrimaryKey() {
        if (!state.database.filterOptions.primaryKey) {
          return;
        }
        const appliedValue = state.database.filters.primaryKeyValue
          ? String(state.database.filters.primaryKeyValue).trim()
          : "";
        if (!appliedValue) {
          if (elements.dbPkInput) {
            elements.dbPkInput.value = "";
          }
          updatePrimaryKeyButtonState();
          return;
        }
        state.database.filters.primaryKeyValue = null;
        if (elements.dbPkInput) {
          elements.dbPkInput.value = "";
        }
        updatePrimaryKeyButtonState();
        state.database.pagination.offset = 0;
        loadDatabaseRows().catch(err => showToast(err.message, "error"));
      }

      function updateDateControlState() {
        const dateColumns = state.database.filterOptions.dateColumns ?? [];
        const loading = state.database.loadingTables || state.database.loadingRows;
        const selectedColumn = elements.dbDateColumn ? elements.dbDateColumn.value : "";
        const hasSelection = Boolean(selectedColumn && dateColumns.includes(selectedColumn));

        if (elements.dbDateFrom) {
          elements.dbDateFrom.disabled = !hasSelection || loading;
        }
        if (elements.dbDateTo) {
          elements.dbDateTo.disabled = !hasSelection || loading;
        }

        const fromValue = elements.dbDateFrom ? elements.dbDateFrom.value : "";
        const toValue = elements.dbDateTo ? elements.dbDateTo.value : "";
        const hasValues = fromValue.length > 0 || toValue.length > 0;

        if (elements.dbDateApply) {
          elements.dbDateApply.disabled = !hasSelection || loading || !hasValues;
        }

        if (elements.dbDateClear) {
          const applied = state.database.filters.dateRange;
          const appliedMatches = applied && applied.column === selectedColumn && (applied.from || applied.to);
          elements.dbDateClear.disabled = (!hasSelection && !appliedMatches && !hasValues) || loading;
        }
      }

      function handleApplyDateRange() {
        if (!elements.dbDateColumn) return;
        const column = elements.dbDateColumn.value;
        if (!column || !(state.database.filterOptions.dateColumns ?? []).includes(column)) {
          showToast("Select a date column first.", "info");
          return;
        }
        const fromValue = elements.dbDateFrom ? elements.dbDateFrom.value.trim() : "";
        const toValue = elements.dbDateTo ? elements.dbDateTo.value.trim() : "";
        if (!fromValue && !toValue) {
          showToast("Provide at least one boundary.", "info");
          return;
        }
        state.database.filters.dateRange = {
          column,
          from: fromValue || null,
          to: toValue || null,
        };
        state.database.pagination.offset = 0;
        updateDateControlState();
        loadDatabaseRows().catch(err => showToast(err.message, "error"));
      }

      function handleClearDateRange() {
        const hasApplied = Boolean(state.database.filters.dateRange);
        if (elements.dbDateFrom) elements.dbDateFrom.value = "";
        if (elements.dbDateTo) elements.dbDateTo.value = "";
        state.database.filters.dateRange = null;
        updateDateControlState();
        if (hasApplied) {
          state.database.pagination.offset = 0;
          loadDatabaseRows().catch(err => showToast(err.message, "error"));
        }
      }

      async function loadDatabaseTables(force = false) {
        if (!force && state.database.tables.length > 0) {
          renderDatabaseExplorer();
          return;
        }
        state.database.loadingTables = true;
        state.database.tablesError = null;
        renderDatabaseTableList();
        renderDatabaseFilters();

        let rowsError = null;
        try {
          const data = await fetchJson(`${API_BASE}/db/tables`);
          state.database.tables = Array.isArray(data.tables) ? data.tables : [];
        } catch (error) {
          state.database.tables = [];
          state.database.tablesError = error instanceof Error ? error.message : String(error);
          renderDatabaseExplorer();
          state.database.loadingTables = false;
          throw error;
        }

        if (
          state.database.activeTable &&
          !state.database.tables.some(table => table.name === state.database.activeTable)
        ) {
          state.database.activeTable = null;
        }

        renderDatabaseTableList();

        try {
          if (!state.database.activeTable && state.database.tables.length > 0) {
            await setActiveDatabaseTable(state.database.tables[0].name, { resetSearch: true });
          } else if (state.database.activeTable) {
            await loadDatabaseRows();
          } else {
            renderDatabaseContent();
          }
        } catch (error) {
          rowsError = error;
        } finally {
          state.database.loadingTables = false;
        }

        if (rowsError) {
          throw rowsError;
        }
      }

      async function setActiveDatabaseTable(tableName, { resetSearch = true } = {}) {
        if (!tableName) return;
        const isSameTable = tableName === state.database.activeTable;
        if (!isSameTable) {
          state.database.activeTable = tableName;
          state.database.pagination.offset = 0;
          state.database.orderBy = null;
          state.database.direction = "ASC";
          state.database.selectedColumns = [];
          state.database.filters = {
            equals: {},
            nulls: {},
            dateRange: null,
            primaryKeyValue: null,
          };
        }
        if (resetSearch || !isSameTable) {
          state.database.search = "";
          state.database.pagination.offset = 0;
        }
        renderDatabaseExplorer();
        await loadDatabaseRows();
      }

      async function loadDatabaseRows() {
        const table = state.database.activeTable;
        if (!table) {
          state.database.rows = [];
          state.database.columns = [];
          state.database.rowsError = null;
          state.database.schema = [];
          state.database.selectedColumns = [];
          state.database.pagination = {
            ...state.database.pagination,
            offset: 0,
            total: 0,
            hasMore: false,
          };
          renderDatabaseFilters();
          renderDatabaseContent();
          return;
        }

        if (state.database.loadingRows) {
          return;
        }

        state.database.loadingRows = true;
        state.database.rowsError = null;
        renderDatabaseContent();
        updatePrimaryKeyButtonState();
        updateDateControlState();

        try {
          const payload = {
            table,
            limit: state.database.pagination.limit,
            offset: state.database.pagination.offset,
          };

          const selectedColumns = Array.isArray(state.database.selectedColumns)
            ? state.database.selectedColumns.filter(column => typeof column === "string" && column.length > 0)
            : [];
          if (selectedColumns.length > 0) {
            payload.columns = selectedColumns;
          }

          const searchValue = typeof state.database.search === "string"
            ? state.database.search.trim()
            : "";
          if (searchValue.length > 0) {
            payload.search = searchValue;
          }
          if (state.database.orderBy) {
            payload.orderBy = state.database.orderBy;
            payload.direction = state.database.direction;
          }

          const filtersPayload = {};
          const equalsEntries = Object.entries(state.database.filters.equals ?? {})
            .filter(([, value]) => value !== undefined && value !== null && String(value).length > 0)
            .map(([column, value]) => ({ column, value }));
          if (equalsEntries.length) {
            filtersPayload.equals = equalsEntries;
          }

          const nullEntries = Object.entries(state.database.filters.nulls ?? {})
            .filter(([, mode]) => mode === 'null' || mode === 'notNull')
            .map(([column, mode]) => ({ column, mode }));
          if (nullEntries.length) {
            filtersPayload.nulls = nullEntries;
          }

          const dateRange = state.database.filters.dateRange;
          if (
            dateRange &&
            typeof dateRange.column === "string" &&
            dateRange.column.length > 0 &&
            (dateRange.from || dateRange.to)
          ) {
            filtersPayload.dateRange = {
              column: dateRange.column,
              from: dateRange.from ?? null,
              to: dateRange.to ?? null,
            };
          }

          if (Object.keys(filtersPayload).length > 0) {
            payload.filters = filtersPayload;
          }

          const primaryKeyValue = state.database.filters.primaryKeyValue;
          if (primaryKeyValue && String(primaryKeyValue).trim().length > 0) {
            payload.primaryKeyValue = primaryKeyValue;
          }

          const data = await fetchJson(`${API_BASE}/db/query`, {
            method: "POST",
            body: JSON.stringify(payload),
          });

          state.database.schema = Array.isArray(data.schema) ? data.schema : state.database.schema;
          state.database.columns = Array.isArray(data.columns) ? data.columns : [];
          state.database.rows = Array.isArray(data.rows) ? data.rows : [];
          const pagination = data.pagination ?? {};
          const limit = Number.isFinite(pagination.limit)
            ? pagination.limit
            : state.database.pagination.limit;
          const offset = Number.isFinite(pagination.offset)
            ? pagination.offset
            : state.database.pagination.offset;
          const total = Number.isFinite(pagination.total) ? pagination.total : 0;
          const hasMore =
            typeof pagination.hasMore === "boolean"
              ? pagination.hasMore
              : offset + limit < total;
          state.database.pagination = {
            limit,
            offset,
            total,
            hasMore,
          };
          state.database.searchableColumns = Array.isArray(data.searchableColumns)
            ? data.searchableColumns
            : [];
          state.database.orderBy = data.orderBy || null;
          state.database.direction =
            (data.direction || "ASC").toUpperCase() === "DESC" ? "DESC" : "ASC";
          state.database.selectedColumns = Array.isArray(data.selectedColumns)
            ? data.selectedColumns.filter(column => typeof column === "string")
            : state.database.columns.map(column => column.name);
          state.database.filterOptions = {
            primaryKey: data.filterOptions?.primaryKey ?? null,
            dateColumns: Array.isArray(data.filterOptions?.dateColumns)
              ? data.filterOptions.dateColumns
              : [],
            enumValues: data.filterOptions?.enumValues ?? {},
            nullableColumns: Array.isArray(data.filterOptions?.nullableColumns)
              ? data.filterOptions.nullableColumns
              : [],
          };

          const appliedFilters = data.appliedFilters ?? {};
          const appliedEquals = Array.isArray(appliedFilters.equals)
            ? appliedFilters.equals.reduce((acc, entry) => {
                if (entry && typeof entry.column === "string" && entry.value !== undefined && entry.value !== null) {
                  acc[entry.column] = String(entry.value);
                }
                return acc;
              }, {})
            : {};
          const appliedNulls = Array.isArray(appliedFilters.nulls)
            ? appliedFilters.nulls.reduce((acc, entry) => {
                if (
                  entry &&
                  typeof entry.column === "string" &&
                  (entry.mode === 'null' || entry.mode === 'notNull')
                ) {
                  acc[entry.column] = entry.mode;
                }
                return acc;
              }, {})
            : {};
          let appliedDateRange = null;
          if (appliedFilters.dateRange && typeof appliedFilters.dateRange === 'object') {
            const column = typeof appliedFilters.dateRange.column === 'string'
              ? appliedFilters.dateRange.column
              : null;
            if (column) {
              const from = typeof appliedFilters.dateRange.from === 'string'
                ? appliedFilters.dateRange.from
                : null;
              const to = typeof appliedFilters.dateRange.to === 'string'
                ? appliedFilters.dateRange.to
                : null;
              appliedDateRange = { column, from, to };
            }
          }
          const appliedPrimaryKeyValue =
            appliedFilters.primaryKeyValue !== undefined && appliedFilters.primaryKeyValue !== null
              ? String(appliedFilters.primaryKeyValue)
              : null;

          state.database.filters = {
            equals: appliedEquals,
            nulls: appliedNulls,
            dateRange: appliedDateRange,
            primaryKeyValue: appliedPrimaryKeyValue,
          };

          state.database.search = typeof data.search === "string" ? data.search : "";
          renderDatabaseFilters();
          renderDatabaseContent();
        } catch (error) {
          state.database.rows = [];
          state.database.columns = [];
          state.database.rowsError = error instanceof Error ? error.message : String(error);
          renderDatabaseFilters();
          renderDatabaseContent();
          throw error;
        } finally {
          state.database.loadingRows = false;
        }
      }

      function handleDatabaseSearch() {
        if (!state.database.activeTable || state.database.loadingRows || state.database.loadingTables) return;
        if (!state.database.searchableColumns.length) {
          showToast("This table has no searchable text columns.", "info");
          return;
        }
        const input = elements.dbSearchInput?.value.trim() ?? "";
        state.database.search = input;
        state.database.pagination.offset = 0;
        loadDatabaseRows().catch(err => showToast(err.message, "error"));
      }

      function handleDatabaseClearSearch() {
        if (!state.database.activeTable || state.database.loadingRows || state.database.loadingTables) return;
        if (!state.database.search && !elements.dbSearchInput?.value) return;
        state.database.search = "";
        state.database.pagination.offset = 0;
        if (elements.dbSearchInput) {
          elements.dbSearchInput.value = "";
        }
        loadDatabaseRows().catch(err => showToast(err.message, "error"));
      }

      function handleDatabaseRefresh() {
        if (!state.database.activeTable || state.database.loadingRows || state.database.loadingTables) return;
        loadDatabaseRows().catch(err => showToast(err.message, "error"));
      }

      function changeDatabasePage(direction) {
        if (!state.database.activeTable || state.database.loadingRows || state.database.loadingTables) return;
        const { limit, offset, total, hasMore } = state.database.pagination;
        if (direction > 0) {
          const nextHasMore = hasMore ?? offset + limit < total;
          if (!nextHasMore) return;
          state.database.pagination.offset = offset + limit;
        } else {
          if (offset === 0) return;
          state.database.pagination.offset = Math.max(offset - limit, 0);
        }
        loadDatabaseRows().catch(err => showToast(err.message, "error"));
      }

      function handleDatabaseSort(column) {
        if (!state.database.activeTable || state.database.loadingRows || state.database.loadingTables || !column) return;
        if (!state.database.columns.some(col => col.name === column)) return;
        if (state.database.orderBy === column) {
          state.database.direction = state.database.direction === "ASC" ? "DESC" : "ASC";
        } else {
          state.database.orderBy = column;
          state.database.direction = "ASC";
        }
        state.database.pagination.offset = 0;
        loadDatabaseRows().catch(err => showToast(err.message, "error"));
      }

      function bindDatabaseEvents() {
        if (elements.dbTableList) {
          elements.dbTableList.addEventListener("click", event => {
            const target = event.target instanceof HTMLElement
              ? event.target.closest("[data-table-name]")
              : null;
            if (!target) return;
            const tableName = target.dataset.tableName;
            if (!tableName) return;
            const resetSearch = tableName !== state.database.activeTable;
            setActiveDatabaseTable(tableName, { resetSearch })
              .catch(err => showToast(err.message, "error"));
          });
        }

        elements.dbReloadSchema?.addEventListener("click", () => {
          loadDatabaseTables(true).catch(err => showToast(err.message, "error"));
        });

        elements.dbSearchButton?.addEventListener("click", handleDatabaseSearch);
        elements.dbClearSearch?.addEventListener("click", handleDatabaseClearSearch);
        elements.dbRefreshTable?.addEventListener("click", handleDatabaseRefresh);
        elements.dbPrevPage?.addEventListener("click", () => changeDatabasePage(-1));
        elements.dbNextPage?.addEventListener("click", () => changeDatabasePage(1));

        elements.dbPkApply?.addEventListener("click", handleApplyPrimaryKey);
        elements.dbPkClear?.addEventListener("click", handleClearPrimaryKey);
        elements.dbPkInput?.addEventListener("input", updatePrimaryKeyButtonState);

        elements.dbDateColumn?.addEventListener("change", () => {
          updateDateControlState();
        });
        elements.dbDateFrom?.addEventListener("input", updateDateControlState);
        elements.dbDateTo?.addEventListener("input", updateDateControlState);
        elements.dbDateApply?.addEventListener("click", handleApplyDateRange);
        elements.dbDateClear?.addEventListener("click", handleClearDateRange);

        if (elements.dbSearchInput) {
          elements.dbSearchInput.addEventListener("keydown", event => {
            if (event.key === "Enter") {
              handleDatabaseSearch();
            }
          });
        }

        if (elements.dbTableHead) {
          elements.dbTableHead.addEventListener("click", event => {
            const target = event.target instanceof HTMLElement
              ? event.target.closest("[data-column]")
              : null;
            if (!target) return;
            const column = target.dataset.column;
            if (column) {
              handleDatabaseSort(column);
            }
          });
        }
      }

      function showToast(message, type = "info", timeout = 3200) {
        const toast = document.createElement("div");
        toast.className = `toast toast-${type}`;
        toast.textContent = message;
        toastRoot.appendChild(toast);
        requestAnimationFrame(() => toast.classList.add("show"));
        setTimeout(() => {
          toast.classList.remove("show");
          setTimeout(() => toast.remove(), 200);
        }, timeout);
      }

      function setLastUpdated(source) {
        const ts = new Date().toLocaleTimeString("de-DE");
        elements.lastUpdated.textContent = `${source} | ${ts}`;
      }

      function updateHeader(view) {
        elements.headerText.textContent = viewDescriptions[view] || viewDescriptions.dashboard;
      }

      function switchView(view) {
        if (!elements.views[view]) {
          return;
        }
        state.currentView = view;
        elements.navButtons.forEach(btn => {
          btn.classList.toggle("active", btn.dataset.view === view);
        });
        Object.entries(elements.views).forEach(([name, node]) => {
          node.classList.toggle("active", name === view);
        });
        updateHeader(view);
        const loader = viewLoaders[view];
        if (typeof loader === "function") {
          loader().catch(err => {
            console.error(err);
            showToast(`Failed to load ${view}: ${err.message}`, "error");
          });
        }
      }

      function setAutoRefresh(enabled) {
        if (state.autoTimer) {
          clearInterval(state.autoTimer);
          state.autoTimer = null;
        }
        state.autoRefresh = enabled;
        elements.autoToggle.checked = enabled;
        elements.autoLabel.textContent = enabled ? "auto refresh every 30s" : "auto refresh off";
        localStorage.setItem("admin:autoRefresh", enabled ? "1" : "0");
        if (enabled) {
          state.autoTimer = setInterval(() => {
            if (state.currentView === "dashboard") {
              loadDashboard().catch(err => console.error(err));
            }
          }, DASHBOARD_INTERVAL);
        }
      }

      async function loadDashboard() {
        elements.systemStatus.innerHTML = `<div class="muted">Loading system status...</div>`;
        elements.serviceStatus.innerHTML = `<div class="muted">Loading service configuration...</div>`;
        elements.seriesOverview.innerHTML = `<div class="muted">Loading series overview...</div>`;
        try {
          const [status, stats, config] = await Promise.all([
            fetchJson(`${API_BASE}/status`),
            fetchJson(`${API_BASE}/stats`),
            fetchJson(`${API_BASE}/config`),
          ]);
          renderStats(stats);
          renderSeriesOverview(stats.seriesSamples || []);
          renderSystemStatus(status);
          renderServiceStatus(config);
          setLastUpdated("dashboard");
        } catch (error) {
          elements.systemStatus.innerHTML = `<div class="alert alert-error">${escapeHtml(error.message)}</div>`;
          elements.serviceStatus.innerHTML = `<div class="alert alert-error">${escapeHtml(error.message)}</div>`;
          renderSeriesOverview([]);
          throw error;
        }
      }

      function renderStats(stats) {
        const media = stats.media || {};
        const thumbs = stats.thumbnails || {};
        const db = stats.database || {};
        const cast = stats.cast || {};
        elements.statTotalMedia.textContent = media.total ?? "-";
        elements.statMovieCount.textContent = media.movies ?? "-";
        elements.statShowCount.textContent = media.series ?? "-";
        elements.statSeasonCount.textContent = media.seasons ?? "-";
        elements.statEpisodeCount.textContent = media.episodes ?? "-";
        elements.statCastCount.textContent = cast.members ?? "-";
        elements.statThumbTotal.textContent = thumbs.total ?? "-";
        elements.statDbSize.textContent = db.size ?? "-";
        elements.statDbPath.textContent = db.path ?? "path unknown";
      }

      function renderSystemStatus(status) {
        if (!status || status.status !== "ok") {
          elements.systemStatusChip.innerHTML = `<span class="chip chip-danger">error</span>`;
        } else {
          elements.systemStatusChip.innerHTML = `<span class="chip chip-success">online</span>`;
        }
        if (status?.uptime?.formatted) {
          elements.statUptime.textContent = status.uptime.formatted;
        }
        if (status?.process?.pid) {
          elements.statPid.textContent = status.process.pid;
        }
        if (status?.system?.nodeVersion) {
          elements.statNode.textContent = status.system.nodeVersion;
        }
        const rows = [
          { label: "Uptime (seconds)", value: status?.uptime?.seconds ?? "-" },
          { label: "RSS", value: status?.memory?.rss ?? "-" },
          { label: "Heap total", value: status?.memory?.heapTotal ?? "-" },
          { label: "Heap used", value: status?.memory?.heapUsed ?? "-" },
          { label: "Platform", value: status?.system?.platform ?? "-" },
          { label: "Architecture", value: status?.system?.arch ?? "-" },
          { label: "CPU count", value: status?.system?.cpus ?? "-" },
          { label: "Free memory", value: status?.system?.freeMemory ?? "-" },
          { label: "Total memory", value: status?.system?.totalMemory ?? "-" },
        ];
        elements.systemStatus.innerHTML = rows.map(row => `
          <div class="info-item">
            <span class="label">${escapeHtml(row.label)}</span>
            <span class="value">${escapeHtml(row.value)}</span>
          </div>
        `).join("");
      }

      function renderServiceStatus(config) {
        const items = [
          { name: "Tautulli", enabled: !!config.tautulli?.enabled, detail: config.tautulli?.url ?? "" },
          { name: "TMDB", enabled: !!config.tmdb?.enabled, detail: config.tmdb?.accessToken ? "access token set" : "" },
          { name: "API auth", enabled: !!config.auth?.enabled, detail: config.auth?.token ? "token set" : "" },
        ];
        elements.serviceStatus.innerHTML = items.map(item => `
          <div class="info-item">
            <span class="label">${escapeHtml(item.name)}</span>
            <span class="value">
              <span class="chip ${item.enabled ? "chip-success" : "chip-danger"}">${item.enabled ? "enabled" : "disabled"}</span>
            </span>
          </div>
          ${item.detail ? `<div class="muted">${escapeHtml(item.detail)}</div>` : ""}
        `).join("");
      }

      function renderSeriesOverview(samples) {
        if (!Array.isArray(samples) || samples.length === 0) {
          elements.seriesOverview.innerHTML = `<div class="muted">No series sample data available yet.</div>`;
          return;
        }

        const content = samples.map(sample => {
          const title = escapeHtml(sample.title ?? 'Untitled');
          const seasonCount = escapeHtml(String(sample.seasonCount ?? '-'));
          const episodeCount = escapeHtml(String(sample.episodeCount ?? '-'));

          const seasonsArray = Array.isArray(sample.seasons) ? sample.seasons : [];
          const seasonsSummary = seasonsArray.length
            ? seasonsArray
                .map(season => {
                  const number = escapeHtml(String(season?.number ?? '?'));
                  const episodes = escapeHtml(String(season?.episodeCount ?? 0));
                  return `S${number} (${episodes})`;
                })
                .join(', ')
            : 'n/a';

          const castArray = Array.isArray(sample.cast) ? sample.cast : [];
          const castSummary = castArray.length
            ? castArray
                .map(member => {
                  const name = member?.name ? escapeHtml(member.name) : '';
                  if (!name) return null;
                  const character = member?.character ? ` as ${escapeHtml(member.character)}` : '';
                  return `${name}${character}`;
                })
                .filter(Boolean)
                .join(', ')
            : 'n/a';

          return `
            <div class="info-item">
              <span class="label">${title}</span>
              <span class="value">Seasons ${seasonCount} • Episodes ${episodeCount}</span>
            </div>
            <div class="muted">Seasons: ${seasonsSummary || 'n/a'}</div>
            <div class="muted">Cast: ${castSummary || 'n/a'}</div>
          `;
        }).join('');

        elements.seriesOverview.innerHTML = content;
      }

      async function loadConfigSnapshot() {
        elements.configView.innerHTML = `<div class="muted">Loading configuration...</div>`;
        try {
          const data = await fetchJson(`${API_BASE}/config`);
          const sections = Object.entries(data).map(([key, value]) => `
            <details>
              <summary>${escapeHtml(key)}</summary>
              <pre>${escapeHtml(JSON.stringify(value, null, 2))}</pre>
            </details>
          `).join("");
          elements.configView.innerHTML = sections || `<div class="muted">No configuration data.</div>`;
        } catch (error) {
          elements.configView.innerHTML = `<div class="alert alert-error">${escapeHtml(error.message)}</div>`;
          throw error;
        }
      }

      function renderTmdbStatus(status) {
        state.tmdbStatus = status || null;
        if (!elements.tmdbTokenStatus) return;
        if (!status || !status.enabled) {
          elements.tmdbTokenStatus.textContent = status?.fromEnv
            ? "Active token provided via environment configuration."
            : "No TMDb token stored yet.";
        } else {
          const preview = status.tokenPreview ? ` (${status.tokenPreview})` : "";
          const updated = status.updatedAt
            ? ` — updated ${new Date(status.updatedAt).toLocaleString("de-DE")}`
            : "";
          const sourceLabel = status.source === "database" ? "stored in database" : "provided via environment";
          elements.tmdbTokenStatus.textContent = `Token ${sourceLabel}${preview}${updated}`;
        }
        if (elements.tmdbClearButton) {
          elements.tmdbClearButton.disabled = !status || !status.fromDatabase;
        }
        if (elements.tmdbTestButton) {
          elements.tmdbTestButton.disabled = false;
        }
      }

      async function loadTmdbStatus() {
        if (!elements.tmdbTokenStatus) return;
        elements.tmdbTokenStatus.textContent = "Loading TMDb status...";
        try {
          const data = await fetchJson(`${API_BASE}/tmdb`);
          renderTmdbStatus(data);
          if (elements.tmdbTestOutput) {
            elements.tmdbTestOutput.textContent = "No test executed yet.";
          }
        } catch (error) {
          elements.tmdbTokenStatus.textContent = `Failed to load TMDb status: ${error.message}`;
          throw error;
        }
      }

      function renderResendStatus(status) {
        state.resendStatus = status || null;
        if (!elements.resendStatus) return;
        if (!status || !status.enabled) {
          elements.resendStatus.textContent = status?.fromEnv
            ? "Active configuration provided via environment variables."
            : "No Resend configuration stored yet.";
        } else {
          const apiKeyPreview = status.apiKeyPreview ? ` (${status.apiKeyPreview})` : "";
          const fromEmail = status.fromEmail ? ` | From: ${status.fromEmail}` : "";
          const updated = status.updatedAt
            ? ` — updated ${new Date(status.updatedAt).toLocaleString("de-DE")}`
            : "";
          const sourceLabel = status.source === "database" ? "stored in database" : "provided via environment";
          elements.resendStatus.textContent = `Configuration ${sourceLabel}${apiKeyPreview}${fromEmail}${updated}`;
        }
        if (elements.resendClearButton) {
          elements.resendClearButton.disabled = !status || !status.fromDatabase;
        }
        if (elements.resendTestButton) {
          elements.resendTestButton.disabled = false;
        }
      }

      async function loadResendStatus() {
        if (!elements.resendStatus) return;
        elements.resendStatus.textContent = "Loading Resend status...";
        try {
          const data = await fetchJson(`${API_BASE}/resend/settings`);
          renderResendStatus(data);
          if (elements.resendTestOutput) {
            elements.resendTestOutput.textContent = "No test executed yet.";
          }
        } catch (error) {
          elements.resendStatus.textContent = `Failed to load Resend status: ${error.message}`;
          throw error;
        }
      }

      async function handleSaveResend(event) {
        event?.preventDefault();
        if (!elements.resendSaveButton || !elements.resendApiKeyInput || !elements.resendFromEmailInput) return;
        const apiKey = elements.resendApiKeyInput.value.trim();
        const fromEmail = elements.resendFromEmailInput.value.trim();
        if (!apiKey || !fromEmail) {
          showToast("Please enter both API key and from email address.", "error");
          return;
        }
        elements.resendSaveButton.disabled = true;
        if (elements.resendTestButton) elements.resendTestButton.disabled = true;
        if (elements.resendClearButton) elements.resendClearButton.disabled = true;
        try {
          await fetchJson(`${API_BASE}/resend/settings`, {
            method: "PUT",
            body: JSON.stringify({ apiKey, fromEmail }),
          });
          elements.resendApiKeyInput.value = "";
          elements.resendFromEmailInput.value = "";
          // Reload status to update state
          await loadResendStatus();
          if (elements.resendTestOutput) {
            elements.resendTestOutput.textContent = "Configuration saved. Run a test to verify.";
          }
          showToast("Resend configuration stored successfully.", "success");
        } catch (error) {
          showToast(error.message, "error");
        } finally {
          elements.resendSaveButton.disabled = false;
          if (elements.resendTestButton) elements.resendTestButton.disabled = false;
          if (elements.resendClearButton) {
            elements.resendClearButton.disabled = !state.resendStatus || !state.resendStatus.fromDatabase;
          }
        }
      }

      async function handleTestResend(event) {
        event?.preventDefault();
        if (!elements.resendTestButton || !elements.resendTestToInput) return;
        const toEmail = elements.resendTestToInput.value.trim();
        if (!toEmail) {
          if (elements.resendTestOutput) {
            elements.resendTestOutput.textContent = "Please enter a recipient email address.";
          }
          showToast("Please enter a recipient email address to send the test.", "error");
          return;
        }
        if (!state.resendStatus?.enabled) {
          if (elements.resendTestOutput) {
            elements.resendTestOutput.textContent = "Please save Resend configuration before running a test.";
          }
          showToast("Please save Resend configuration before running a test.", "error");
          return;
        }
        elements.resendTestButton.disabled = true;
        if (elements.resendTestOutput) {
          elements.resendTestOutput.textContent = "Sending test email...";
        }
        try {
          const data = await fetchJson(`${API_BASE}/test/resend`, {
            method: "POST",
            body: JSON.stringify({ to: toEmail }),
          });
          let message = `Success: Test email sent to ${toEmail}`;
          if (data.id) {
            message += ` | Email ID: ${data.id}`;
          }
          if (elements.resendTestOutput) {
            elements.resendTestOutput.textContent = message;
          }
          showToast("Resend test email sent successfully.", "success");
        } catch (error) {
          if (elements.resendTestOutput) {
            elements.resendTestOutput.textContent = `Error: ${error.message}`;
          }
          showToast(error.message, "error");
        } finally {
          elements.resendTestButton.disabled = false;
        }
      }

      async function handleClearResend(event) {
        event?.preventDefault();
        if (!elements.resendClearButton) return;
        if (!state.resendStatus?.fromDatabase) {
          showToast("There is no stored Resend configuration to remove.", "info");
          return;
        }
        elements.resendClearButton.disabled = true;
        try {
          const data = await fetchJson(`${API_BASE}/resend/settings`, { method: "DELETE" });
          renderResendStatus(data.status);
          if (elements.resendTestOutput) {
            elements.resendTestOutput.textContent = "Stored configuration removed. Provide configuration to test.";
          }
          showToast("Stored Resend configuration removed.", "success");
        } catch (error) {
          showToast(error.message, "error");
          elements.resendClearButton.disabled = false;
        }
      }

      function formatWelcomeTimestamp(value) {
        if (!value) return "—";
        const parsed = new Date(value);
        if (Number.isNaN(parsed.getTime())) {
          return value;
        }
        return parsed.toLocaleString("de-DE");
      }

      function renderWelcomeEmailStats(stats) {
        if (!elements.welcomeStats) return;
        state.welcomeEmail.stats = stats ?? null;
        if (!stats) {
          elements.welcomeStats.classList.add("muted");
          elements.welcomeStats.textContent = "No welcome emails sent yet.";
          return;
        }
        elements.welcomeStats.classList.remove("muted");
        const total = typeof stats.total === "number" ? numberFormatter.format(stats.total) : String(stats.total ?? "0");
        const sent = typeof stats.sent === "number" ? numberFormatter.format(stats.sent) : String(stats.sent ?? "0");
        const failed = typeof stats.failed === "number" ? numberFormatter.format(stats.failed) : String(stats.failed ?? "0");
        const successRate = typeof stats.successRate === "string" ? stats.successRate : String(stats.successRate ?? "0%");
        elements.welcomeStats.innerHTML = `
          <div>Total: ${escapeHtml(total)}</div>
          <div>Sent: ${escapeHtml(sent)}</div>
          <div>Failed: ${escapeHtml(failed)}</div>
          <div>Success rate: ${escapeHtml(successRate)}</div>
        `;
      }

      function renderWelcomeEmailHistory(emails) {
        if (!elements.welcomeHistory) return;
        const list = Array.isArray(emails) ? emails : [];
        state.welcomeEmail.history = list;
        if (list.length === 0) {
          elements.welcomeHistory.classList.add("muted");
          elements.welcomeHistory.textContent = "No welcome emails have been sent yet.";
          return;
        }
        elements.welcomeHistory.classList.remove("muted");
        elements.welcomeHistory.innerHTML = list
          .map((entry) => {
            const emailValue = typeof entry.email === "string" ? entry.email : "";
            const escapedEmail = escapeHtml(emailValue);
            const entryIdValue = typeof entry.id === "string" ? entry.id : "";
            const escapedEntryId = escapeHtml(entryIdValue);
            const statusRaw = typeof entry.status === "string" ? entry.status : "unknown";
            const statusKey = statusRaw.toLowerCase();
            const statusLabel = statusRaw.charAt(0).toUpperCase() + statusRaw.slice(1);
            const statusClass =
              statusKey === "sent" || statusKey === "failed" ? `history-status ${statusKey}` : "history-status";
            const timestamp = escapeHtml(formatWelcomeTimestamp(entry.sentAt ?? entry.createdAt));
            const emailId = entry.emailId ? escapeHtml(entry.emailId) : "";
            const metaParts = [timestamp];
            if (emailId) {
              metaParts.push(`ID: ${emailId}`);
            }
            const prefillButton = emailValue
              ? `<button type="button" class="btn btn-compact" data-action="prefill-welcome-email" data-email="${escapedEmail}">Use email</button>`
              : "";
            const deleteEntryButton = entryIdValue
              ? `<button type="button" class="btn btn-danger btn-compact" data-action="delete-welcome-entry" data-entry-id="${escapedEntryId}" data-email="${escapedEmail}">Delete entry</button>`
              : "";
            const deleteRecipientButton = emailValue
              ? `<button type="button" class="btn btn-danger btn-compact" data-action="delete-welcome-recipient" data-email="${escapedEmail}">Delete all for recipient</button>`
              : "";
            const actions = [prefillButton, deleteEntryButton, deleteRecipientButton].filter(Boolean).join("");

            return `
              <div class="history-row" data-entry-id="${escapedEntryId}" data-email="${escapedEmail}">
                <div class="history-meta">
                  <div class="history-details">
                    <strong>${escapedEmail || "Unknown recipient"}</strong>
                    <span class="muted">${metaParts.join(" · ")}</span>
                  </div>
                  <span class="${statusClass}">${escapeHtml(statusLabel)}</span>
                </div>
                <div class="history-actions">
                  ${actions || '<span class="muted">No actions available.</span>'}
                </div>
              </div>
            `;
          })
          .join("");
      }

      async function loadWelcomeEmailStats() {
        if (!elements.welcomeStats) return;
        state.welcomeEmail.loadingStats = true;
        elements.welcomeStats.classList.add("muted");
        elements.welcomeStats.textContent = "Loading welcome email statistics...";
        try {
          const response = await fetchJson(`${WELCOME_EMAIL_API_BASE}/stats`);
          renderWelcomeEmailStats(response?.data ?? null);
        } catch (error) {
          const message = getErrorMessage(error, "Failed to load welcome email statistics.");
          elements.welcomeStats.classList.remove("muted");
          elements.welcomeStats.innerHTML = `<span class="error-text">${escapeHtml(message)}</span>`;
          throw new Error(message);
        } finally {
          state.welcomeEmail.loadingStats = false;
        }
      }

      async function loadWelcomeEmailHistory(limit = 10) {
        if (!elements.welcomeHistory) return;
        state.welcomeEmail.loadingHistory = true;
        elements.welcomeHistory.classList.add("muted");
        elements.welcomeHistory.textContent = "Loading welcome email history...";
        try {
          const response = await fetchJson(`${WELCOME_EMAIL_API_BASE}/history?limit=${limit}`);
          renderWelcomeEmailHistory(response?.data ?? []);
        } catch (error) {
          const message = getErrorMessage(error, "Failed to load welcome email history.");
          elements.welcomeHistory.classList.remove("muted");
          elements.welcomeHistory.innerHTML = `<span class="error-text">${escapeHtml(message)}</span>`;
          throw new Error(message);
        } finally {
          state.welcomeEmail.loadingHistory = false;
        }
      }

      async function handleSendWelcomeEmail(event) {
        event?.preventDefault();
        if (!elements.welcomeSendButton || !elements.welcomeEmailInput) return;
        const email = elements.welcomeEmailInput.value.trim();
        const name = elements.welcomeNameInput?.value.trim() ?? "";
        const toolUrl = elements.welcomeUrlInput?.value.trim() ?? "";
        if (!email) {
          showToast("Please enter the recipient email address.", "error");
          return;
        }
        if (!state.resendStatus?.enabled) {
          showToast("Configure Resend before sending welcome emails.", "error");
          return;
        }
        elements.welcomeSendButton.disabled = true;
        if (elements.welcomeCheckButton) elements.welcomeCheckButton.disabled = true;
        if (elements.welcomeReloadButton) elements.welcomeReloadButton.disabled = true;
        if (elements.welcomeStatus) {
          elements.welcomeStatus.textContent = `Sending welcome email to ${email}...`;
        }
        const payload = { email };
        if (name) {
          payload.recipientName = name;
        }
        if (toolUrl) {
          payload.toolUrl = toolUrl;
        }
        try {
          const data = await fetchJson(`${WELCOME_EMAIL_API_BASE}`, {
            method: "POST",
            body: JSON.stringify(payload),
          });
          if (elements.welcomeStatus) {
            let message = `Welcome email sent to ${email}.`;
            if (data?.emailId) {
              message += ` Email ID: ${data.emailId}`;
            }
            elements.welcomeStatus.textContent = message;
          }
          showToast("Welcome email sent successfully.", "success");
          try {
            await loadWelcomeEmailStats();
          } catch (statsError) {
            console.error(statsError);
          }
          try {
            await loadWelcomeEmailHistory();
          } catch (historyError) {
            console.error(historyError);
          }
        } catch (error) {
          const message = getErrorMessage(error, "Failed to send welcome email.");
          if (elements.welcomeStatus) {
            elements.welcomeStatus.textContent = `Failed to send welcome email: ${message}`;
          }
          const isConflict = typeof message === "string" && message.toLowerCase().includes("already been sent");
          showToast(message, isConflict ? "info" : "error");
        } finally {
          elements.welcomeSendButton.disabled = false;
          if (elements.welcomeCheckButton) elements.welcomeCheckButton.disabled = false;
          if (elements.welcomeReloadButton) elements.welcomeReloadButton.disabled = false;
        }
      }

      async function handleCheckWelcomeEmail(event) {
        event?.preventDefault();
        if (!elements.welcomeCheckButton || !elements.welcomeEmailInput) return;
        const email = elements.welcomeEmailInput.value.trim();
        if (!email) {
          showToast("Please enter the recipient email address.", "error");
          return;
        }
        elements.welcomeCheckButton.disabled = true;
        if (elements.welcomeStatus) {
          elements.welcomeStatus.textContent = `Checking welcome email status for ${email}...`;
        }
        try {
          const data = await fetchJson(`${WELCOME_EMAIL_API_BASE}/check/${encodeURIComponent(email)}`);
          const hasReceived = Boolean(data?.hasReceived);
          if (elements.welcomeStatus) {
            elements.welcomeStatus.textContent = hasReceived
              ? `A welcome email has already been sent to ${email}.`
              : `No welcome email has been sent to ${email} yet.`;
          }
          showToast(
            hasReceived ? `Welcome email already sent to ${email}.` : `No welcome email sent to ${email} yet.`,
            hasReceived ? "info" : "success",
          );
        } catch (error) {
          const message = getErrorMessage(error, "Failed to check welcome email status.");
          if (elements.welcomeStatus) {
            elements.welcomeStatus.textContent = `Failed to check welcome email status: ${message}`;
          }
          showToast(message, "error");
        } finally {
          elements.welcomeCheckButton.disabled = false;
        }
      }

      async function handleReloadWelcomeEmail(event) {
        event?.preventDefault();
        if (!elements.welcomeReloadButton) return;
        elements.welcomeReloadButton.disabled = true;
        try {
          await loadWelcomeEmailStats();
          await loadWelcomeEmailHistory();
          showToast("Welcome email data reloaded.", "success");
        } catch (error) {
          const message = getErrorMessage(error, "Failed to reload welcome email data.");
          showToast(message, "error");
        } finally {
          elements.welcomeReloadButton.disabled = false;
        }
      }

      async function handleDeleteWelcomeEmailEntry(entryId, email, triggerButton) {
        if (!entryId) {
          showToast("Entry identifier is missing.", "error");
          return;
        }
        const button = triggerButton instanceof HTMLButtonElement ? triggerButton : null;
        const originalLabel = button?.textContent ?? "";
        if (button) {
          button.disabled = true;
          button.textContent = "Removing...";
        }
        try {
          const data = await fetchJson(`${WELCOME_EMAIL_API_BASE}/history/${encodeURIComponent(entryId)}`, {
            method: "DELETE",
          });
          const message =
            data?.message ??
            (email ? `Removed welcome email entry for ${email}.` : "Welcome email entry removed.");
          showToast(message, "success");
          try {
            await loadWelcomeEmailStats();
          } catch (statsError) {
            console.error(statsError);
          }
          try {
            await loadWelcomeEmailHistory();
          } catch (historyError) {
            console.error(historyError);
          }
        } catch (error) {
          const message = getErrorMessage(error, "Failed to delete welcome email entry.");
          showToast(message, "error");
        } finally {
          if (button) {
            button.disabled = false;
            button.textContent = originalLabel || "Delete entry";
          }
        }
      }

      async function handleDeleteWelcomeEmailsForRecipient(email, triggerButton) {
        if (!email) {
          showToast("No recipient email provided.", "error");
          return;
        }
        const button = triggerButton instanceof HTMLButtonElement ? triggerButton : null;
        const originalLabel = button?.textContent ?? "";
        if (button) {
          button.disabled = true;
          button.textContent = "Removing...";
        }
        try {
          const data = await fetchJson(`${WELCOME_EMAIL_API_BASE}/recipient/${encodeURIComponent(email)}`, {
            method: "DELETE",
          });
          const message = data?.message ?? `Removed welcome email entries for ${email}.`;
          showToast(message, "success");
          try {
            await loadWelcomeEmailStats();
          } catch (statsError) {
            console.error(statsError);
          }
          try {
            await loadWelcomeEmailHistory();
          } catch (historyError) {
            console.error(historyError);
          }
        } catch (error) {
          const message = getErrorMessage(error, "Failed to delete welcome emails for recipient.");
          showToast(message, "error");
        } finally {
          if (button) {
            button.disabled = false;
            button.textContent = originalLabel || "Delete all for recipient";
          }
        }
      }

      function prefillWelcomeEmailRecipient(email) {
        if (!email || !elements.welcomeEmailInput) {
          showToast("No recipient email available for prefill.", "error");
          return;
        }
        elements.welcomeEmailInput.value = email;
        elements.welcomeEmailInput.focus();
        if (elements.welcomeStatus) {
          elements.welcomeStatus.textContent = `Recipient set to ${email}.`;
        }
        showToast(`Recipient set to ${email}.`, "info");
      }

      function handleWelcomeHistoryAction(event) {
        const target = event.target instanceof HTMLElement
          ? event.target.closest("button[data-action]")
          : null;
        if (!target) {
          return;
        }
        const action = target.dataset.action;
        if (action === "prefill-welcome-email") {
          prefillWelcomeEmailRecipient(target.dataset.email ?? "");
          return;
        }
        if (action === "delete-welcome-entry") {
          const entryId = target.dataset.entryId ?? "";
          const email = target.dataset.email ?? "";
          void handleDeleteWelcomeEmailEntry(entryId, email, target);
          return;
        }
        if (action === "delete-welcome-recipient") {
          const email = target.dataset.email ?? "";
          void handleDeleteWelcomeEmailsForRecipient(email, target);
        }
      }

      async function handleClearWelcomeEmailHistory(event) {
        event?.preventDefault();
        if (!elements.welcomeClearButton) return;
        elements.welcomeClearButton.disabled = true;
        const originalLabel = elements.welcomeClearButton.textContent;
        elements.welcomeClearButton.textContent = "Clearing...";
        try {
          const data = await fetchJson(`${WELCOME_EMAIL_API_BASE}/history`, { method: "DELETE" });
          const message = data?.message ?? "Welcome email history cleared.";
          showToast(message, data?.deleted > 0 ? "success" : "info");
          try {
            await loadWelcomeEmailStats();
          } catch (statsError) {
            console.error(statsError);
          }
          try {
            await loadWelcomeEmailHistory();
          } catch (historyError) {
            console.error(historyError);
          }
        } catch (error) {
          const message = getErrorMessage(error, "Failed to clear welcome email history.");
          showToast(message, "error");
        } finally {
          elements.welcomeClearButton.disabled = false;
          elements.welcomeClearButton.textContent = originalLabel ?? "Clear history";
        }
      }

      async function handleTestResendDiag(event) {
        event?.preventDefault();
        if (!elements.resendTestButtonDiag || !elements.resendTestEmail) return;
        const recipientEmail = elements.resendTestEmail.value.trim();
        if (!recipientEmail) {
          showToast("Please enter a recipient email address.", "error");
          if (elements.resendDiagOutput) {
            elements.resendDiagOutput.textContent = "Please enter a recipient email address.";
          }
          return;
        }
        elements.resendTestButtonDiag.disabled = true;
        if (elements.resendDiagOutput) {
          elements.resendDiagOutput.textContent = "Sending test email...";
        }
        try {
          const data = await fetchJson(`${API_BASE}/test/resend`, {
            method: "POST",
            body: JSON.stringify({ to: recipientEmail }),
          });
          let message = `Success: Test email sent to ${recipientEmail}`;
          if (data.emailId) {
            message += ` | Email ID: ${data.emailId}`;
          }
          if (elements.resendDiagOutput) {
            elements.resendDiagOutput.textContent = message;
          }
          showToast("Test email sent successfully.", "success");
        } catch (error) {
          if (elements.resendDiagOutput) {
            elements.resendDiagOutput.textContent = `Error: ${error.message}`;
          }
          showToast(error.message, "error");
        } finally {
          elements.resendTestButtonDiag.disabled = false;
        }
      }

      async function loadConfig() {
        await Promise.all([
          loadTmdbStatus(),
          loadResendStatus(),
          loadWelcomeEmailStats(),
          loadWelcomeEmailHistory(),
          loadConfigSnapshot(),
        ]);
        setLastUpdated("configuration");
      }

      async function handleSaveTmdbToken(event) {
        event?.preventDefault();
        if (!elements.tmdbSaveButton || !elements.tmdbTokenInput) return;
        const token = elements.tmdbTokenInput.value.trim();
        if (!token) {
          showToast("Please enter a TMDb access token before saving.", "error");
          return;
        }
        elements.tmdbSaveButton.disabled = true;
        if (elements.tmdbTestButton) elements.tmdbTestButton.disabled = true;
        if (elements.tmdbClearButton) elements.tmdbClearButton.disabled = true;
        try {
          const data = await fetchJson(`${API_BASE}/tmdb`, {
            method: "POST",
            body: JSON.stringify({ token }),
          });
          elements.tmdbTokenInput.value = "";
          renderTmdbStatus(data.status);
          if (elements.tmdbTestOutput) {
            elements.tmdbTestOutput.textContent = "Token saved. Run a test to verify.";
          }
          showToast("TMDb token stored successfully.", "success");
        } catch (error) {
          showToast(error.message, "error");
        } finally {
          elements.tmdbSaveButton.disabled = false;
          if (elements.tmdbTestButton) elements.tmdbTestButton.disabled = false;
          if (elements.tmdbClearButton) {
            elements.tmdbClearButton.disabled = !state.tmdbStatus || !state.tmdbStatus.fromDatabase;
          }
        }
      }

      async function handleTestTmdbToken(event) {
        event?.preventDefault();
        if (!elements.tmdbTestButton) return;
        const token = elements.tmdbTokenInput ? elements.tmdbTokenInput.value.trim() : "";
        if (!token && !state.tmdbStatus?.enabled) {
          if (elements.tmdbTestOutput) {
            elements.tmdbTestOutput.textContent = "Enter a token or save one before running a test.";
          }
          showToast("Provide a token to run the TMDb test.", "error");
          return;
        }
        elements.tmdbTestButton.disabled = true;
        if (elements.tmdbTestOutput) {
          elements.tmdbTestOutput.textContent = "Testing token...";
        }
        try {
          const data = await fetchJson(`${API_BASE}/test/tmdb`, {
            method: "POST",
            body: JSON.stringify(token ? { token } : {}),
          });
          let message = `Success: ${data.message}`;
          if (typeof data.tokenPreview === "string" && data.tokenPreview) {
            message += ` (${data.tokenPreview})`;
          }
          if (typeof data.rateLimitRemaining === "number" && Number.isFinite(data.rateLimitRemaining)) {
            message += ` | Remaining budget: ${data.rateLimitRemaining}`;
          }
          if (elements.tmdbTestOutput) {
            elements.tmdbTestOutput.textContent = message;
          }
          showToast("TMDb token test succeeded.", "success");
        } catch (error) {
          if (elements.tmdbTestOutput) {
            elements.tmdbTestOutput.textContent = `Error: ${error.message}`;
          }
          showToast(error.message, "error");
        } finally {
          elements.tmdbTestButton.disabled = false;
        }
      }

      async function handleClearTmdbToken(event) {
        event?.preventDefault();
        if (!elements.tmdbClearButton) return;
        if (!state.tmdbStatus?.fromDatabase) {
          showToast("There is no stored TMDb token to remove.", "info");
          return;
        }
        elements.tmdbClearButton.disabled = true;
        try {
          const data = await fetchJson(`${API_BASE}/tmdb`, { method: "DELETE" });
          renderTmdbStatus(data.status);
          if (elements.tmdbTestOutput) {
            elements.tmdbTestOutput.textContent = "Stored token removed. Provide a token to test.";
          }
          showToast("Stored TMDb token removed.", "success");
        } catch (error) {
          showToast(error.message, "error");
          elements.tmdbClearButton.disabled = false;
        }
      }

      async function loadLogs() {
        elements.logView.innerHTML = `<div class="muted">Loading log buffer...</div>`;
        try {
          const params = new URLSearchParams();
          const limit = parseInt(elements.logLimit.value, 10);
          if (!Number.isNaN(limit)) {
            params.set("limit", String(limit));
          }
          const level = elements.logLevel.value;
          if (level) {
            params.set("level", level);
          }
          const data = await fetchJson(`${API_BASE}/logs?${params.toString()}`);
          const logs = data.logs || [];
          if (logs.length === 0) {
            elements.logView.textContent = "No logs available.";
          } else {
            elements.logView.innerHTML = logs.map(entry => {
              const context = entry.context ? `\n${JSON.stringify(entry.context, null, 2)}` : "";
              return `
                <div class="log-entry">
                  <span class="log-meta">${escapeHtml(entry.timestamp)}</span>
                  <span class="log-meta">${escapeHtml(entry.level)}</span>
                  ${escapeHtml(entry.message)}
                  ${context ? `<pre>${escapeHtml(context)}</pre>` : ""}
                </div>
              `;
            }).join("");
            elements.logView.scrollTop = elements.logView.scrollHeight;
          }
          const stats = data.stats || {};
          elements.logSummary.textContent = `entries ${stats.total ?? logs.length} | error ${stats.byLevel?.error ?? 0} | warn ${stats.byLevel?.warn ?? 0}`;
          setLastUpdated("logs");
        } catch (error) {
          elements.logView.innerHTML = `<div class="alert alert-error">${escapeHtml(error.message)}</div>`;
          throw error;
        }
      }

      async function handleClearLogs() {
        try {
          await fetchJson(`${API_BASE}/logs`, { method: "DELETE" });
          elements.logView.textContent = "Log buffer cleared.";
          elements.logSummary.textContent = "entries 0";
          showToast("Log buffer cleared", "info");
        } catch (error) {
          showToast(error.message, "error");
        }
      }

      async function runTautulliTest() {
        elements.tautulliButton.disabled = true;
        elements.tautulliOutput.textContent = "Testing Tautulli connection...";
        try {
          const data = await fetchJson(`${API_BASE}/test/tautulli`, { method: "POST" });
          elements.tautulliOutput.textContent = `Success: ${data.libraries ?? 0} libraries reachable.`;
          showToast("Tautulli test succeeded", "success");
        } catch (error) {
          elements.tautulliOutput.textContent = `Error: ${error.message}`;
          showToast(error.message, "error");
        } finally {
          elements.tautulliButton.disabled = false;
        }
      }

      async function runDbTest() {
        elements.dbButton.disabled = true;
        elements.dbOutput.textContent = "Checking database...";
        try {
          const data = await fetchJson(`${API_BASE}/test/database`, { method: "POST" });
          elements.dbOutput.textContent = `Success: ${data.recordCount ?? 0} records accessible.`;
          showToast("Database test succeeded", "success");
        } catch (error) {
          elements.dbOutput.textContent = `Error: ${error.message}`;
          showToast(error.message, "error");
        } finally {
          elements.dbButton.disabled = false;
        }
      }

      function bindEvents() {
        elements.navButtons.forEach(btn => {
          btn.addEventListener("click", () => switchView(btn.dataset.view));
        });
        bindDatabaseEvents();
        if (elements.tmdbTestButton) elements.tmdbTestButton.disabled = true;
        if (elements.tmdbClearButton) elements.tmdbClearButton.disabled = true;
        if (elements.resendTestButton) elements.resendTestButton.disabled = true;
        if (elements.resendClearButton) elements.resendClearButton.disabled = true;
        elements.refreshButton.addEventListener("click", () => {
          const loader = viewLoaders[state.currentView];
          if (loader) {
            loader().catch(err => showToast(err.message, "error"));
          }
        });
        elements.autoToggle.addEventListener("change", event => setAutoRefresh(event.target.checked));
        elements.refreshLogs.addEventListener("click", () => loadLogs().catch(err => showToast(err.message, "error")));
        elements.clearLogs.addEventListener("click", handleClearLogs);
        elements.logLevel.addEventListener("change", () => loadLogs().catch(err => showToast(err.message, "error")));
        elements.logLimit.addEventListener("change", () => loadLogs().catch(err => showToast(err.message, "error")));
        elements.tautulliButton.addEventListener("click", runTautulliTest);
        elements.dbButton.addEventListener("click", runDbTest);
        if (elements.tmdbSaveButton) {
          elements.tmdbSaveButton.addEventListener("click", handleSaveTmdbToken);
        }
        if (elements.tmdbTestButton) {
          elements.tmdbTestButton.addEventListener("click", handleTestTmdbToken);
        }
        if (elements.tmdbClearButton) {
          elements.tmdbClearButton.addEventListener("click", handleClearTmdbToken);
        }
        if (elements.resendSaveButton) {
          elements.resendSaveButton.addEventListener("click", handleSaveResend);
        }
        if (elements.resendTestButton) {
          elements.resendTestButton.addEventListener("click", handleTestResend);
        }
        if (elements.resendClearButton) {
          elements.resendClearButton.addEventListener("click", handleClearResend);
        }
        if (elements.resendTestButtonDiag) {
          elements.resendTestButtonDiag.addEventListener("click", handleTestResendDiag);
        }
        if (elements.welcomeSendButton) {
          elements.welcomeSendButton.addEventListener("click", handleSendWelcomeEmail);
        }
        if (elements.welcomeCheckButton) {
          elements.welcomeCheckButton.addEventListener("click", handleCheckWelcomeEmail);
        }
        if (elements.welcomeReloadButton) {
          elements.welcomeReloadButton.addEventListener("click", handleReloadWelcomeEmail);
        }
        if (elements.welcomeClearButton) {
          elements.welcomeClearButton.addEventListener("click", handleClearWelcomeEmailHistory);
        }
        if (elements.welcomeHistory) {
          elements.welcomeHistory.addEventListener("click", handleWelcomeHistoryAction);
        }
      }

      // Tautulli Sync Functions
      let availableLibraries = [];
      let selectedLibraryIds = new Set();

      async function loadAvailableLibraries() {
        try {
          const res = await fetch("/admin/api/tautulli/libraries");
          if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
          const data = await res.json();
          availableLibraries = data.libraries || [];
          renderLibraryList();
          showToast("Libraries loaded", "success");
        } catch (err) {
          showToast(err.message, "error");
        }
      }

      function renderLibraryList() {
        const container = document.getElementById("library-list");
        if (availableLibraries.length === 0) {
          container.innerHTML = '<div class="muted">No libraries found</div>';
          return;
        }
        container.innerHTML = availableLibraries.map(lib => `
          <label style="display: block; margin: 8px 0;">
            <input type="checkbox" value="${lib.sectionId}" class="library-checkbox"
              ${selectedLibraryIds.has(lib.sectionId) ? 'checked' : ''}>
            ${lib.friendlyName || lib.sectionName} (${lib.sectionType})
          </label>
        `).join('');
        document.querySelectorAll('.library-checkbox').forEach(cb => {
          cb.addEventListener('change', (e) => {
            const id = parseInt(e.target.value);
            if (e.target.checked) {
              selectedLibraryIds.add(id);
            } else {
              selectedLibraryIds.delete(id);
            }
            updateSelectedLibraries();
          });
        });
        updateSelectedLibraries();
      }

      function updateSelectedLibraries() {
        const container = document.getElementById('selected-libraries');
        const list = document.getElementById('selected-libraries-list');
        if (selectedLibraryIds.size === 0) {
          container.style.display = 'none';
          return;
        }
        container.style.display = 'block';
        const selected = availableLibraries.filter(lib => selectedLibraryIds.has(lib.sectionId));
        list.innerHTML = selected.map(lib =>
          `<div style="padding: 4px 0;">${lib.friendlyName || lib.sectionName} (${lib.sectionType})</div>`
        ).join('');
      }

      async function saveLibraryConfiguration() {
        try {
          console.log('selectedLibraryIds:', selectedLibraryIds);
          console.log('availableLibraries:', availableLibraries);
          const selected = availableLibraries.filter(lib => selectedLibraryIds.has(lib.sectionId));
          console.log('selected libraries:', selected);
          const payload = {
            sections: selected.map(lib => ({
              sectionId: lib.sectionId,
              sectionName: lib.sectionName,
              sectionType: lib.sectionType,
              enabled: true
            }))
          };
          console.log('Sending payload:', payload);
          const res = await fetch("/admin/api/tautulli/library-sections", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          showToast("Library configuration saved", "success");
          await loadLibrarySections();
        } catch (err) {
          showToast(err.message, "error");
        }
      }

      async function loadLibrarySections() {
        try {
          const res = await fetch("/admin/api/tautulli/library-sections");
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          const container = document.getElementById("library-sections-list");
          if (!data.sections || data.sections.length === 0) {
            container.innerHTML = '<div class="muted">No libraries configured</div>';
            return;
          }
          container.innerHTML = data.sections.map(s => `
            <div style="padding: 8px; background: var(--color-surface); border-radius: 8px; margin: 4px 0;">
              <strong>${s.sectionName}</strong> (${s.sectionType}) - ${s.enabled ? 'Enabled' : 'Disabled'}
            </div>
          `).join('');
        } catch (err) {
          showToast(err.message, "error");
        }
      }

      async function startManualSync() {
        try {
          const incremental = document.getElementById("sync-incremental").checked;
          const enrichWithTmdb = document.getElementById("sync-tmdb").checked;
          const syncCovers = document.getElementById("sync-covers").checked;

          const res = await fetch("/admin/api/tautulli/sync/manual", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ incremental, enrichWithTmdb, syncCovers })
          });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);

          document.getElementById("sync-status").textContent = "Sync im Hintergrund gestartet. Prüfen Sie die Logs für den Fortschritt.";
          showToast("Sync started", "success");
        } catch (err) {
          showToast(err.message, "error");
        }
      }

      async function saveSchedule() {
        try {
          const jobType = document.getElementById("schedule-job-type").value;
          const cronExpression = document.getElementById("schedule-cron").value;
          const enabled = document.getElementById("schedule-enabled").checked;

          const res = await fetch("/admin/api/tautulli/sync/schedules", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ jobType, cronExpression, enabled })
          });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);

          showToast("Schedule saved", "success");
          await loadSchedules();
        } catch (err) {
          showToast(err.message, "error");
        }
      }

      async function loadSchedules() {
        try {
          const res = await fetch("/admin/api/tautulli/sync/schedules");
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          const container = document.getElementById("schedules-list");
          if (!data.schedules || data.schedules.length === 0) {
            container.innerHTML = '<div class="muted">No schedules configured</div>';
            return;
          }
          container.innerHTML = data.schedules.map(s => `
            <div style="padding: 8px; background: var(--color-surface); border-radius: 8px; margin: 4px 0;">
              <strong>${s.jobType}</strong>: ${s.cronExpression} - ${s.enabled ? 'Enabled' : 'Disabled'}
              ${s.lastRunAt ? `<br><small>Last run: ${new Date(s.lastRunAt).toLocaleString()}</small>` : ''}
            </div>
          `).join('');
        } catch (err) {
          showToast(err.message, "error");
        }
      }

      async function loadTautulliConfig() {
        try {
          const res = await fetch("/admin/api/tautulli/config");
          const data = await res.json();

          if (data.configured) {
            document.getElementById("tautulli-url").value = data.tautulliUrl || "";
            document.getElementById("tautulli-config-status").textContent =
              "Configuration loaded. API Key is set.";
            document.getElementById("tautulli-config-status").classList.remove("error");
          } else {
            document.getElementById("tautulli-config-status").textContent =
              "No configuration found. Please enter Tautulli URL and API Key.";
            document.getElementById("tautulli-config-status").classList.add("muted");
          }
        } catch (err) {
          document.getElementById("tautulli-config-status").textContent =
            "Failed to load configuration: " + err.message;
          document.getElementById("tautulli-config-status").classList.add("error");
        }
      }

      async function saveTautulliConfig() {
        const url = document.getElementById("tautulli-url").value.trim();
        const apiKey = document.getElementById("tautulli-api-key").value.trim();
        const statusEl = document.getElementById("tautulli-config-status");

        if (!url || !apiKey) {
          statusEl.textContent = "Please enter both Tautulli URL and API Key";
          statusEl.classList.add("error");
          return;
        }

        try {
          statusEl.textContent = "Saving configuration...";
          statusEl.classList.remove("error");

          const res = await fetch("/admin/api/tautulli/config", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ tautulliUrl: url, apiKey }),
          });

          if (!res.ok) {
            const errData = await res.json();
            throw new Error(errData.message || "Failed to save configuration");
          }

          const data = await res.json();
          statusEl.textContent = "Configuration saved successfully!";
          statusEl.classList.remove("error");

          // Clear API key input for security
          document.getElementById("tautulli-api-key").value = "";

          showToast("Tautulli configuration saved", "success");
        } catch (err) {
          statusEl.textContent = "Failed to save: " + err.message;
          statusEl.classList.add("error");
          showToast(err.message, "error");
        }
      }

      async function testTautulliConnection() {
        const url = document.getElementById("tautulli-url").value.trim();
        const apiKey = document.getElementById("tautulli-api-key").value.trim();
        const statusEl = document.getElementById("tautulli-config-status");

        try {
          statusEl.textContent = "Testing connection...";
          statusEl.classList.remove("error");

          const body = url && apiKey ? { tautulliUrl: url, apiKey } : {};

          const res = await fetch("/admin/api/tautulli/config/test", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });

          if (!res.ok) {
            const errData = await res.json();
            throw new Error(errData.message || "Connection test failed");
          }

          const data = await res.json();
          statusEl.textContent = `Connection successful! Found ${data.libraryCount} libraries.`;
          statusEl.classList.remove("error");
          showToast("Connection test successful", "success");
        } catch (err) {
          statusEl.textContent = "Connection test failed: " + err.message;
          statusEl.classList.add("error");
          showToast(err.message, "error");
        }
      }

      function bindTautulliSyncEvents() {
        const btnSaveConfig = document.getElementById("btn-save-tautulli-config");
        const btnTestConnection = document.getElementById("btn-test-connection");
        const showApiKeyCheckbox = document.getElementById("show-api-key");
        const apiKeyInput = document.getElementById("tautulli-api-key");
        const btnLoadLibs = document.getElementById("btn-load-libraries");
        const btnSaveLibs = document.getElementById("btn-save-libraries");
        const btnStartSync = document.getElementById("btn-start-sync");
        const btnSaveSchedule = document.getElementById("btn-save-schedule");

        if (btnSaveConfig) btnSaveConfig.addEventListener("click", saveTautulliConfig);
        if (btnTestConnection) btnTestConnection.addEventListener("click", testTautulliConnection);
        if (showApiKeyCheckbox) {
          showApiKeyCheckbox.addEventListener("change", (e) => {
            apiKeyInput.type = e.target.checked ? "text" : "password";
          });
        }
        if (btnLoadLibs) btnLoadLibs.addEventListener("click", loadAvailableLibraries);
        if (btnSaveLibs) btnSaveLibs.addEventListener("click", saveLibraryConfiguration);
        if (btnStartSync) btnStartSync.addEventListener("click", startManualSync);
        if (btnSaveSchedule) btnSaveSchedule.addEventListener("click", saveSchedule);
      }

      function init() {
        bindEvents();
        bindTautulliSyncEvents();
        const stored = localStorage.getItem("admin:autoRefresh") === "1";
        setAutoRefresh(stored);
        loadDashboard().catch(err => showToast(err.message, "error"));
        loadLibrarySections().catch(() => {});
        loadSchedules().catch(() => {});
      }

      window.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "visible" && state.autoRefresh && !state.autoTimer) {
          setAutoRefresh(true);
        }
      });

      init();
    })();
  </script>
</body>
</html>
